<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cannon: cannon::logic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cannon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecannon_1_1logic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cannon::logic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing classes representing CNF formulas and tooling for solving CNF formulas.  
<a href="namespacecannon_1_1logic.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1And.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the boolean AND operator.  <a href="classcannon_1_1logic_1_1And.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1AndGate.html">AndGate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an AND gate covertable to CNF.  <a href="structcannon_1_1logic_1_1AndGate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1AssignmentHeuristic.html">AssignmentHeuristic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor representing an assignment choice heuristic.  <a href="classcannon_1_1logic_1_1AssignmentHeuristic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Atomic.html">Atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an atomic proposition.  <a href="classcannon_1_1logic_1_1Atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1Circuit.html">Circuit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class serving as the basis for other circuits. Circuits can be composed by connecting input and output propositions.  <a href="structcannon_1_1logic_1_1Circuit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a clause in a Conjunctive Normal Form (CNF) formula, which is defined as a disjunction of literals.  <a href="classcannon_1_1logic_1_1Clause.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a Conjunctive Normal Form formula, which is a conjunction of Clauses.  <a href="classcannon_1_1logic_1_1CNFFormula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html">DPLLState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the state of the DPLL/CDCL algorithm. Manages a frontier of formula states in order to perform search for satisfying assignments.  <a href="classcannon_1_1logic_1_1DPLLState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1FalseComparator.html">FalseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a comparison function that always returns false.  <a href="structcannon_1_1logic_1_1FalseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class representing a boolean formula.  <a href="classcannon_1_1logic_1_1Formula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the state of a formula on the frontier explored by the DPLL algorithm, which includes a partial assignment and associated formula simplification. This class also keeps information to assist backtracking and clause learning.  <a href="classcannon_1_1logic_1_1FormulaState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1FullAdder.html">FullAdder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a full adder convertible to CNF. See <a href="https://en.wikipedia.org/wiki/Adder_(electronics)">https://en.wikipedia.org/wiki/Adder_(electronics)</a>  <a href="structcannon_1_1logic_1_1FullAdder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Iff.html">Iff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a boolean if-and-only-if operator.  <a href="classcannon_1_1logic_1_1Iff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Implies.html">Implies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a boolean implication operator.  <a href="classcannon_1_1logic_1_1Implies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Literal.html">Literal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a single literal in a CNF formula.  <a href="classcannon_1_1logic_1_1Literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1NandGate.html">NandGate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a NAND gate convertible to CNF.  <a href="structcannon_1_1logic_1_1NandGate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1NBitAdder.html">NBitAdder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an Adder for an arbitrary number of bits, convertible to CNF.  <a href="structcannon_1_1logic_1_1NBitAdder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Negation.html">Negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the negation of a contained formula.  <a href="classcannon_1_1logic_1_1Negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1Or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a boolean OR operator.  <a href="classcannon_1_1logic_1_1Or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1OrGate.html">OrGate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an OR gate convertible to CNF.  <a href="structcannon_1_1logic_1_1OrGate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1PropositionHeuristic.html">PropositionHeuristic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor representing a proposition choice heuristic.  <a href="classcannon_1_1logic_1_1PropositionHeuristic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1RandomComparator.html">RandomComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a comparison function that returns a random comparison result for all indices in a set. This comparison is consistent, as the random choices are cached.  <a href="structcannon_1_1logic_1_1RandomComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1TwoClauseComparator.html">TwoClauseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a comparison function that considers one proposition greater than another if it participates in a greater number of two-clauses in a formula.  <a href="structcannon_1_1logic_1_1TwoClauseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1VsidsComparator.html">VsidsComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a comparison function that considers one proposition greater than another if it has a greater VSIDS value.  <a href="structcannon_1_1logic_1_1VsidsComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcannon_1_1logic_1_1XorGate.html">XorGate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an XOR gate convertible to CNF.  <a href="structcannon_1_1logic_1_1XorGate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab739b3f39030c33d7ae9c7487cccd886"><td class="memItemLeft" align="right" valign="top"><a id="ab739b3f39030c33d7ae9c7487cccd886"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Assignment</b> = std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt;</td></tr>
<tr class="separator:ab739b3f39030c33d7ae9c7487cccd886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe697251147bf553c3ec3cc72d8cc79"><td class="memItemLeft" align="right" valign="top"><a id="a4fe697251147bf553c3ec3cc72d8cc79"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Simplification</b> = std::valarray&lt; bool &gt;</td></tr>
<tr class="separator:a4fe697251147bf553c3ec3cc72d8cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486162304f2f4bfcd5c54892ff905d5e"><td class="memItemLeft" align="right" valign="top"><a id="a486162304f2f4bfcd5c54892ff905d5e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AssignmentParents</b> = std::valarray&lt; int &gt;</td></tr>
<tr class="separator:a486162304f2f4bfcd5c54892ff905d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc519a28a34560a8a627f0c6a880a1e4"><td class="memItemLeft" align="right" valign="top"><a id="acc519a28a34560a8a627f0c6a880a1e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AssignmentLevels</b> = std::valarray&lt; int &gt;</td></tr>
<tr class="separator:acc519a28a34560a8a627f0c6a880a1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58434aa4ff157ac443541cb32daffe"><td class="memItemLeft" align="right" valign="top"><a id="a7f58434aa4ff157ac443541cb32daffe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PropFunc</b> = std::function&lt; unsigned int(const <a class="el" href="classcannon_1_1logic_1_1DPLLState.html">DPLLState</a> &amp;ds, const Assignment &amp;, const Simplification &amp;, std::vector&lt; unsigned int &gt; &amp;)&gt;</td></tr>
<tr class="separator:a7f58434aa4ff157ac443541cb32daffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e627f4be899e3b49977ca7cea3caa"><td class="memItemLeft" align="right" valign="top"><a id="aa50e627f4be899e3b49977ca7cea3caa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AssignFunc</b> = std::function&lt; bool(const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;, const Assignment &amp;, const Simplification &amp;, unsigned int, const std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;)&gt;</td></tr>
<tr class="separator:aa50e627f4be899e3b49977ca7cea3caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ff5e5a357ba31104ac34c0bcb53534"><td class="memItemLeft" align="right" valign="top"><a id="ac9ff5e5a357ba31104ac34c0bcb53534"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Comparator</b> = std::function&lt; bool(const unsigned int &amp;, const unsigned int &amp;)&gt;</td></tr>
<tr class="separator:ac9ff5e5a357ba31104ac34c0bcb53534"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac8c6fcaac3a73bbc7f44ed404536fd35"><td class="memItemLeft" align="right" valign="top"><a id="ac8c6fcaac3a73bbc7f44ed404536fd35"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> { <b>False</b>, 
<b>Unassigned</b>, 
<b>True</b>
 }</td></tr>
<tr class="memdesc:ac8c6fcaac3a73bbc7f44ed404536fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration representing the three possible states that can be assigned to a proposition. <br /></td></tr>
<tr class="separator:ac8c6fcaac3a73bbc7f44ed404536fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb8122b6d16c0fcda35461be74b9ca"><td class="memItemLeft" align="right" valign="top"><a id="a0bbb8122b6d16c0fcda35461be74b9ca"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a> { <b>Satisfiable</b>, 
<b>Unknown</b>, 
<b>Unsatisfiable</b>
 }</td></tr>
<tr class="memdesc:a0bbb8122b6d16c0fcda35461be74b9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing the possible termination states of the DPLL algorithm. <br /></td></tr>
<tr class="separator:a0bbb8122b6d16c0fcda35461be74b9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a100c32a608e7636488f83713e7e1fec8"><td class="memItemLeft" align="right" valign="top"><a id="a100c32a608e7636488f83713e7e1fec8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CANNON_CLASS_FORWARD</b> (<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>)</td></tr>
<tr class="separator:a100c32a608e7636488f83713e7e1fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f32b2968771dae1d610259b941f49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a85f32b2968771dae1d610259b941f49f">generate_random_clause</a> (unsigned int num_props)</td></tr>
<tr class="memdesc:a85f32b2968771dae1d610259b941f49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random 3-clause using propositions 0 to num_props-1.  <a href="namespacecannon_1_1logic.html#a85f32b2968771dae1d610259b941f49f">More...</a><br /></td></tr>
<tr class="separator:a85f32b2968771dae1d610259b941f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8107a18b5b0d27588baa967ccd25aeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a8107a18b5b0d27588baa967ccd25aeb2">generate_random_formula</a> (unsigned int num_props, unsigned int num_clauses)</td></tr>
<tr class="memdesc:a8107a18b5b0d27588baa967ccd25aeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random 3-CNF formula.  <a href="namespacecannon_1_1logic.html#a8107a18b5b0d27588baa967ccd25aeb2">More...</a><br /></td></tr>
<tr class="separator:a8107a18b5b0d27588baa967ccd25aeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c93760359c3ff5fcf8b724ae152365e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a5c93760359c3ff5fcf8b724ae152365e">resolve</a> (<a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;c1, const <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;c2, unsigned int prop)</td></tr>
<tr class="memdesc:a5c93760359c3ff5fcf8b724ae152365e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to resolve two CNF clauses on the input proposition. Throws an exception if the two clauses cannot be resolved on the input prop (i.e., they do not both contain the proposition or the literals containing the proposition don't have opposite negation).  <a href="namespacecannon_1_1logic.html#a5c93760359c3ff5fcf8b724ae152365e">More...</a><br /></td></tr>
<tr class="separator:a5c93760359c3ff5fcf8b724ae152365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e70256c877d30890087d2a96f22c30f"><td class="memItemLeft" align="right" valign="top"><a id="a8e70256c877d30890087d2a96f22c30f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> a)</td></tr>
<tr class="separator:a8e70256c877d30890087d2a96f22c30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abf3e70d1168ae4cd7e38e6a2cfd6c"><td class="memItemLeft" align="right" valign="top"><a id="ab5abf3e70d1168ae4cd7e38e6a2cfd6c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classcannon_1_1logic_1_1Literal.html">Literal</a> &amp;l)</td></tr>
<tr class="separator:ab5abf3e70d1168ae4cd7e38e6a2cfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f70ab5c6ae37c8c94b0264993b4834"><td class="memItemLeft" align="right" valign="top"><a id="a73f70ab5c6ae37c8c94b0264993b4834"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;c)</td></tr>
<tr class="separator:a73f70ab5c6ae37c8c94b0264993b4834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc4f69dbbfde257c7a63553f83b8af8"><td class="memItemLeft" align="right" valign="top"><a id="abcc4f69dbbfde257c7a63553f83b8af8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;f)</td></tr>
<tr class="separator:abcc4f69dbbfde257c7a63553f83b8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6114df230e54bec4a65f0f25a278c27"><td class="memItemLeft" align="right" valign="top"><a id="aa6114df230e54bec4a65f0f25a278c27"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt; &amp;v)</td></tr>
<tr class="separator:aa6114df230e54bec4a65f0f25a278c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0cd801dbec2ca0bdba8488afb755e4"><td class="memItemLeft" align="right" valign="top"><a id="a8c0cd801dbec2ca0bdba8488afb755e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt; &amp;v1, const std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt; &amp;v2)</td></tr>
<tr class="separator:a8c0cd801dbec2ca0bdba8488afb755e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325a837a6833371280b5dae8cf53c365"><td class="memItemLeft" align="right" valign="top"><a id="a325a837a6833371280b5dae8cf53c365"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt; &amp;v1, const std::valarray&lt; <a class="el" href="namespacecannon_1_1logic.html#ac8c6fcaac3a73bbc7f44ed404536fd35">PropAssignment</a> &gt; &amp;v2)</td></tr>
<tr class="separator:a325a837a6833371280b5dae8cf53c365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617bcea309622620bf0068ba8c9123e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a8617bcea309622620bf0068ba8c9123e">default_prop</a> (const <a class="el" href="classcannon_1_1logic_1_1DPLLState.html">DPLLState</a> &amp;ds, const Assignment &amp;a, const Simplification &amp;s, std::vector&lt; unsigned int &gt; &amp;props)</td></tr>
<tr class="memdesc:a8617bcea309622620bf0068ba8c9123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default proposition sorting heuristic. Used to sort propoositions for exploration in the DPLL algorithm.  <a href="namespacecannon_1_1logic.html#a8617bcea309622620bf0068ba8c9123e">More...</a><br /></td></tr>
<tr class="separator:a8617bcea309622620bf0068ba8c9123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb96cc7d3250bb725338d1af7a4897fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#afb96cc7d3250bb725338d1af7a4897fb">default_assign</a> (const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;form, const Assignment &amp;a, const Simplification &amp;s, unsigned int prop, const std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;watched)</td></tr>
<tr class="memdesc:afb96cc7d3250bb725338d1af7a4897fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment choice heuristic. Used to select which boolean assignment to explore first for an input proposition.  <a href="namespacecannon_1_1logic.html#afb96cc7d3250bb725338d1af7a4897fb">More...</a><br /></td></tr>
<tr class="separator:afb96cc7d3250bb725338d1af7a4897fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30877ad3a93e4bd25ff4044065225cec"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a30877ad3a93e4bd25ff4044065225cec">dpll</a> (<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> f, PropFunc ph_func, AssignFunc ah_func, const std::chrono::seconds cutoff=std::chrono::seconds(1200))</td></tr>
<tr class="memdesc:a30877ad3a93e4bd25ff4044065225cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached.  <a href="namespacecannon_1_1logic.html#a30877ad3a93e4bd25ff4044065225cec">More...</a><br /></td></tr>
<tr class="separator:a30877ad3a93e4bd25ff4044065225cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147b22c6baa32122897b17d675aa995d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a147b22c6baa32122897b17d675aa995d">dpll</a> (<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> f, const std::chrono::seconds cutoff=std::chrono::seconds(1200))</td></tr>
<tr class="memdesc:a147b22c6baa32122897b17d675aa995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached. Passes the default proposition and assignment heuristics.  <a href="namespacecannon_1_1logic.html#a147b22c6baa32122897b17d675aa995d">More...</a><br /></td></tr>
<tr class="separator:a147b22c6baa32122897b17d675aa995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23871010acce76afce16ab4891587f37"><td class="memItemLeft" align="right" valign="top"><a id="a23871010acce76afce16ab4891587f37"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a> &amp;r)</td></tr>
<tr class="separator:a23871010acce76afce16ab4891587f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8ac65c84727e3e5d43316893f95d9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Negation.html">Negation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a21e8ac65c84727e3e5d43316893f95d9">make_negation</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f)</td></tr>
<tr class="memdesc:a21e8ac65c84727e3e5d43316893f95d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negation of the input formula.  <a href="namespacecannon_1_1logic.html#a21e8ac65c84727e3e5d43316893f95d9">More...</a><br /></td></tr>
<tr class="separator:a21e8ac65c84727e3e5d43316893f95d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d71b71966cdb6f3fc9c27bebdd2b39e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1And.html">And</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a6d71b71966cdb6f3fc9c27bebdd2b39e">make_and</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; g)</td></tr>
<tr class="memdesc:a6d71b71966cdb6f3fc9c27bebdd2b39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AND of the two input formulas.  <a href="namespacecannon_1_1logic.html#a6d71b71966cdb6f3fc9c27bebdd2b39e">More...</a><br /></td></tr>
<tr class="separator:a6d71b71966cdb6f3fc9c27bebdd2b39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c0a5bd8d12477abed76ab9786da929"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1And.html">And</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a65c0a5bd8d12477abed76ab9786da929">make_and</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::stack&lt; std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&gt; &amp;fs)</td></tr>
<tr class="memdesc:a65c0a5bd8d12477abed76ab9786da929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AND of an arbitrary number of input formulas.  <a href="namespacecannon_1_1logic.html#a65c0a5bd8d12477abed76ab9786da929">More...</a><br /></td></tr>
<tr class="separator:a65c0a5bd8d12477abed76ab9786da929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e5a239ede47aef70f6bfa6a7895b21"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Or.html">Or</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#ac3e5a239ede47aef70f6bfa6a7895b21">make_or</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; g)</td></tr>
<tr class="memdesc:ac3e5a239ede47aef70f6bfa6a7895b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OR of the two input formulas.  <a href="namespacecannon_1_1logic.html#ac3e5a239ede47aef70f6bfa6a7895b21">More...</a><br /></td></tr>
<tr class="separator:ac3e5a239ede47aef70f6bfa6a7895b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f98adf08656d44387aada2de76bbe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Or.html">Or</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a4a5f98adf08656d44387aada2de76bbe">make_or</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::stack&lt; std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&gt; &amp;fs)</td></tr>
<tr class="memdesc:a4a5f98adf08656d44387aada2de76bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OR of an arbitrary number of input formulas.  <a href="namespacecannon_1_1logic.html#a4a5f98adf08656d44387aada2de76bbe">More...</a><br /></td></tr>
<tr class="separator:a4a5f98adf08656d44387aada2de76bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ed1bc20d9fdfd82bbbe6e00464fdad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Implies.html">Implies</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#aa3ed1bc20d9fdfd82bbbe6e00464fdad">make_implies</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; g)</td></tr>
<tr class="memdesc:aa3ed1bc20d9fdfd82bbbe6e00464fdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an implication operator for the input formulas.  <a href="namespacecannon_1_1logic.html#aa3ed1bc20d9fdfd82bbbe6e00464fdad">More...</a><br /></td></tr>
<tr class="separator:aa3ed1bc20d9fdfd82bbbe6e00464fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfdd2672c18c609c1a9fcc3a62b905b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Iff.html">Iff</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#aadfdd2672c18c609c1a9fcc3a62b905b">make_iff</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; f, std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt; g)</td></tr>
<tr class="memdesc:aadfdd2672c18c609c1a9fcc3a62b905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IFF operator for the input formulas.  <a href="namespacecannon_1_1logic.html#aadfdd2672c18c609c1a9fcc3a62b905b">More...</a><br /></td></tr>
<tr class="separator:aadfdd2672c18c609c1a9fcc3a62b905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dbc7aa369e58627d19e3b04fc79b8f"><td class="memItemLeft" align="right" valign="top"><a id="af8dbc7aa369e58627d19e3b04fc79b8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CANNON_CLASS_FORWARD</b> (<a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a>)</td></tr>
<tr class="separator:af8dbc7aa369e58627d19e3b04fc79b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc58b3a2c5c003a8e14b148404d4a748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#abc58b3a2c5c003a8e14b148404d4a748">parse_cnf</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abc58b3a2c5c003a8e14b148404d4a748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a conjunctive normal form formula from the input DIMACS string. See <a href="https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html">https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html</a>.  <a href="namespacecannon_1_1logic.html#abc58b3a2c5c003a8e14b148404d4a748">More...</a><br /></td></tr>
<tr class="separator:abc58b3a2c5c003a8e14b148404d4a748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37098c480196beb3681c4358ceacc40c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a37098c480196beb3681c4358ceacc40c">load_cnf</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a37098c480196beb3681c4358ceacc40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a CNF formula from the input DIMACS-formatted file.  <a href="namespacecannon_1_1logic.html#a37098c480196beb3681c4358ceacc40c">More...</a><br /></td></tr>
<tr class="separator:a37098c480196beb3681c4358ceacc40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8ef1c17a4764bc94b56a55381094f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a4c8ef1c17a4764bc94b56a55381094f0">parse_clause</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a4c8ef1c17a4764bc94b56a55381094f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single clause from the input DIMACS string.  <a href="namespacecannon_1_1logic.html#a4c8ef1c17a4764bc94b56a55381094f0">More...</a><br /></td></tr>
<tr class="separator:a4c8ef1c17a4764bc94b56a55381094f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee34a65a188b53ec4e2c4e7edfe6da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a9ee34a65a188b53ec4e2c4e7edfe6da3">parse_clause</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a9ee34a65a188b53ec4e2c4e7edfe6da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single clause from the input DIMACS string.  <a href="namespacecannon_1_1logic.html#a9ee34a65a188b53ec4e2c4e7edfe6da3">More...</a><br /></td></tr>
<tr class="separator:a9ee34a65a188b53ec4e2c4e7edfe6da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d806458695a65950a79a4dd000484bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1logic.html#a8d806458695a65950a79a4dd000484bc">write_cnf</a> (const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;f)</td></tr>
<tr class="memdesc:a8d806458695a65950a79a4dd000484bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a CNF formula to a DIMACS-formatted string.  <a href="namespacecannon_1_1logic.html#a8d806458695a65950a79a4dd000484bc">More...</a><br /></td></tr>
<tr class="separator:a8d806458695a65950a79a4dd000484bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing classes representing CNF formulas and tooling for solving CNF formulas. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afb96cc7d3250bb725338d1af7a4897fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb96cc7d3250bb725338d1af7a4897fb">&#9670;&nbsp;</a></span>default_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cannon::logic::default_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Simplification &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>watched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default assignment choice heuristic. Used to select which boolean assignment to explore first for an input proposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>The formula under consideration. </td></tr>
    <tr><td class="paramname">a</td><td>The current assignment. </td></tr>
    <tr><td class="paramname">s</td><td>The current simplification. </td></tr>
    <tr><td class="paramname">prop</td><td>The proposition to choose an assignment for. </td></tr>
    <tr><td class="paramname">watched</td><td>The watched list for speeding up formula analysis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Assignment chosen by heuristic. </dd></dl>

</div>
</div>
<a id="a8617bcea309622620bf0068ba8c9123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8617bcea309622620bf0068ba8c9123e">&#9670;&nbsp;</a></span>default_prop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cannon::logic::default_prop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcannon_1_1logic_1_1DPLLState.html">DPLLState</a> &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Simplification &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default proposition sorting heuristic. Used to sort propoositions for exploration in the DPLL algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ds</td><td>Current state of DPLL algorithm. </td></tr>
    <tr><td class="paramname">a</td><td>Current assignment </td></tr>
    <tr><td class="paramname">s</td><td>Current simplification </td></tr>
    <tr><td class="paramname">props</td><td>Propositions to sort using default heuristics</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Proposition chosen by this heuristic. </dd></dl>

</div>
</div>
<a id="a147b22c6baa32122897b17d675aa995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147b22c6baa32122897b17d675aa995d">&#9670;&nbsp;</a></span>dpll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int &gt; cannon::logic::dpll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>std::chrono::seconds(1200)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached. Passes the default proposition and assignment heuristics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to check for satisfiability </td></tr>
    <tr><td class="paramname">cutoff</td><td>Maximum amount of time that the algorithm should run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the DPLL algorithm. </dd></dl>

</div>
</div>
<a id="a30877ad3a93e4bd25ff4044065225cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30877ad3a93e4bd25ff4044065225cec">&#9670;&nbsp;</a></span>dpll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int &gt; cannon::logic::dpll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropFunc&#160;</td>
          <td class="paramname"><em>ph_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignFunc&#160;</td>
          <td class="paramname"><em>ah_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>std::chrono::seconds(1200)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to check for satisfiability </td></tr>
    <tr><td class="paramname">ph_func</td><td>Proposition choice heuristic </td></tr>
    <tr><td class="paramname">ah_func</td><td>Assignment choice heuristic </td></tr>
    <tr><td class="paramname">cutoff</td><td>Maximum amount of time that the algorithm should run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the DPLL algorithm. </dd></dl>

</div>
</div>
<a id="a85f32b2968771dae1d610259b941f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f32b2968771dae1d610259b941f49f">&#9670;&nbsp;</a></span>generate_random_clause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> cannon::logic::generate_random_clause </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_props</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random 3-clause using propositions 0 to num_props-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_props</td><td>Maximum number of propositions to choose from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated clause. </dd></dl>

</div>
</div>
<a id="a8107a18b5b0d27588baa967ccd25aeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8107a18b5b0d27588baa967ccd25aeb2">&#9670;&nbsp;</a></span>generate_random_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> cannon::logic::generate_random_formula </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num_clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random 3-CNF formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_props</td><td>Maximum number of propositions to choose from. </td></tr>
    <tr><td class="paramname">num_clauses</td><td>Number of clauses in random formula</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated formula. </dd></dl>

</div>
</div>
<a id="a37098c480196beb3681c4358ceacc40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37098c480196beb3681c4358ceacc40c">&#9670;&nbsp;</a></span>load_cnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> cannon::logic::load_cnf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a CNF formula from the input DIMACS-formatted file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed CNF formula. </dd></dl>

</div>
</div>
<a id="a6d71b71966cdb6f3fc9c27bebdd2b39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d71b71966cdb6f3fc9c27bebdd2b39e">&#9670;&nbsp;</a></span>make_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1And.html">And</a> &gt; cannon::logic::make_and </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AND of the two input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First input formula. </td></tr>
    <tr><td class="paramname">g</td><td>Second input formula.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created AND operator. </dd></dl>

</div>
</div>
<a id="a65c0a5bd8d12477abed76ab9786da929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c0a5bd8d12477abed76ab9786da929">&#9670;&nbsp;</a></span>make_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1And.html">And</a> &gt; cannon::logic::make_and </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AND of an arbitrary number of input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First input formula. </td></tr>
    <tr><td class="paramname">fs</td><td>Stack of input formulas to be chained by AND.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top-level created AND operator. </dd></dl>

</div>
</div>
<a id="aadfdd2672c18c609c1a9fcc3a62b905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfdd2672c18c609c1a9fcc3a62b905b">&#9670;&nbsp;</a></span>make_iff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Iff.html">Iff</a> &gt; cannon::logic::make_iff </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an IFF operator for the input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First input formula. </td></tr>
    <tr><td class="paramname">g</td><td>Second input formula.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created IFF operator. </dd></dl>

</div>
</div>
<a id="aa3ed1bc20d9fdfd82bbbe6e00464fdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ed1bc20d9fdfd82bbbe6e00464fdad">&#9670;&nbsp;</a></span>make_implies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Implies.html">Implies</a> &gt; cannon::logic::make_implies </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an implication operator for the input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The left-hand formula in the implication. </td></tr>
    <tr><td class="paramname">g</td><td>The right-hand formula in the implication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created implication operator. </dd></dl>

</div>
</div>
<a id="a21e8ac65c84727e3e5d43316893f95d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e8ac65c84727e3e5d43316893f95d9">&#9670;&nbsp;</a></span>make_negation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Negation.html">Negation</a> &gt; cannon::logic::make_negation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a negation of the input formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to negate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created negation. </dd></dl>

</div>
</div>
<a id="ac3e5a239ede47aef70f6bfa6a7895b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e5a239ede47aef70f6bfa6a7895b21">&#9670;&nbsp;</a></span>make_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Or.html">Or</a> &gt; cannon::logic::make_or </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an OR of the two input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First input formula. </td></tr>
    <tr><td class="paramname">g</td><td>Second input formula.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created OR operator. </dd></dl>

</div>
</div>
<a id="a4a5f98adf08656d44387aada2de76bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f98adf08656d44387aada2de76bbe">&#9670;&nbsp;</a></span>make_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Or.html">Or</a> &gt; cannon::logic::make_or </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1Formula.html">Formula</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an OR of an arbitrary number of input formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First input formula. </td></tr>
    <tr><td class="paramname">fs</td><td>Stack of input formulas to be chained by OR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top-level created OR operator. </dd></dl>

</div>
</div>
<a id="a9ee34a65a188b53ec4e2c4e7edfe6da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee34a65a188b53ec4e2c4e7edfe6da3">&#9670;&nbsp;</a></span>parse_clause() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> cannon::logic::parse_clause </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a single clause from the input DIMACS string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to parse a clause from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed clause. </dd></dl>

</div>
</div>
<a id="a4c8ef1c17a4764bc94b56a55381094f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8ef1c17a4764bc94b56a55381094f0">&#9670;&nbsp;</a></span>parse_clause() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> cannon::logic::parse_clause </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a single clause from the input DIMACS string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to parse a clause from. Will be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed clause. </dd></dl>

</div>
</div>
<a id="abc58b3a2c5c003a8e14b148404d4a748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc58b3a2c5c003a8e14b148404d4a748">&#9670;&nbsp;</a></span>parse_cnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> cannon::logic::parse_cnf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a conjunctive normal form formula from the input DIMACS string. See <a href="https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html">https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to parse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed CNF formula. </dd></dl>

</div>
</div>
<a id="a5c93760359c3ff5fcf8b724ae152365e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c93760359c3ff5fcf8b724ae152365e">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::logic::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to resolve two CNF clauses on the input proposition. Throws an exception if the two clauses cannot be resolved on the input prop (i.e., they do not both contain the proposition or the literals containing the proposition don't have opposite negation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>First clause to resolve, which will be modified to contain the resolved clause </td></tr>
    <tr><td class="paramname">c2</td><td>Second clause to use in resolution. </td></tr>
    <tr><td class="paramname">prop</td><td>Proposition to resolve on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d806458695a65950a79a4dd000484bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d806458695a65950a79a4dd000484bc">&#9670;&nbsp;</a></span>write_cnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cannon::logic::write_cnf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a CNF formula to a DIMACS-formatted string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to write to string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DIMACS string. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cannon</b></li><li class="navelem"><a class="el" href="namespacecannon_1_1logic.html">logic</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
