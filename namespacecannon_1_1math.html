<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cannon: cannon::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cannon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecannon_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cannon::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing mathematical utilities.  
<a href="namespacecannon_1_1math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1BigUnsigned.html">BigUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an arbitrary-size unsigned integer.  <a href="classcannon_1_1math_1_1BigUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1CubicSpline.html">CubicSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the cubic spline interpolation of a set of points. Following <a href="https://timodenk.com/blog/cubic-spline-interpolation/">https://timodenk.com/blog/cubic-spline-interpolation/</a>.  <a href="classcannon_1_1math_1_1CubicSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1MonomialBasis.html">MonomialBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class satisfying the requirements of a polynomial basis, i.e., providing an static evaluate function. Represents the common monomial basis, in which each basis element is of the form x^n.  <a href="classcannon_1_1math_1_1MonomialBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1MultiSpline.html">MultiSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a multivariate spline, defined by its component coordinate splines.  <a href="classcannon_1_1math_1_1MultiSpline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1MultivariateNormal.html">MultivariateNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a multivariate normal distribution of arbitrary dimensionality.  <a href="classcannon_1_1math_1_1MultivariateNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1nth__derivative.html">nth_derivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor representing the Nth derivative of a function. Note that each level of the derivative is computed by single-order finite difference, so error accumulates quickly.  <a href="classcannon_1_1math_1_1nth__derivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1nth__derivative_3_01F_00_01T_00_011_01_4.html">nth_derivative&lt; F, T, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor representing the base case of recursive finite difference derivatives.  <a href="classcannon_1_1math_1_1nth__derivative_3_01F_00_01T_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1Perlin.html">Perlin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a perlin noise generator.  <a href="classcannon_1_1math_1_1Perlin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1math_1_1Polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a polynomial in a certain basis.  <a href="classcannon_1_1math_1_1Polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a19355a1b67b4f74e2ff269a0f408ea2c"><td class="memItemLeft" align="right" valign="top"><a id="a19355a1b67b4f74e2ff269a0f408ea2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorXu</b> = Matrix&lt; unsigned int, Dynamic, 1 &gt;</td></tr>
<tr class="separator:a19355a1b67b4f74e2ff269a0f408ea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3a87a52fe3eb159404738e2894fc645e"><td class="memItemLeft" align="right" valign="top"><a id="a3a87a52fe3eb159404738e2894fc645e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CANNON_CLASS_FORWARD</b> (<a class="el" href="classcannon_1_1math_1_1MultiSpline.html">MultiSpline</a>)</td></tr>
<tr class="separator:a3a87a52fe3eb159404738e2894fc645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24a42e434bcecb5e6533ff35ed7cdb"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#add24a42e434bcecb5e6533ff35ed7cdb">compute_barycentric_coords</a> (const Vector3d &amp;v0, const Vector3d &amp;v1, const Vector3d &amp;v2, const Vector3d &amp;p)</td></tr>
<tr class="memdesc:add24a42e434bcecb5e6533ff35ed7cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute barycentric coordinates for a query point on triangle defined by its three vertices. See <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>.  <a href="namespacecannon_1_1math.html#add24a42e434bcecb5e6533ff35ed7cdb">More...</a><br /></td></tr>
<tr class="separator:add24a42e434bcecb5e6533ff35ed7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483b745b0fc0a7ef836224d53e32ea4c"><td class="memItemLeft" align="right" valign="top"><a id="a483b745b0fc0a7ef836224d53e32ea4c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classcannon_1_1math_1_1BigUnsigned.html">BigUnsigned</a> &amp;)</td></tr>
<tr class="separator:a483b745b0fc0a7ef836224d53e32ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f81691b6e6b2b0ce10bc775aab264fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a8f81691b6e6b2b0ce10bc775aab264fd">get_digits</a> (unsigned int x, unsigned int base=10)</td></tr>
<tr class="memdesc:a8f81691b6e6b2b0ce10bc775aab264fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of digits of the input number in the input base.  <a href="namespacecannon_1_1math.html#a8f81691b6e6b2b0ce10bc775aab264fd">More...</a><br /></td></tr>
<tr class="separator:a8f81691b6e6b2b0ce10bc775aab264fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae47701769042a62fb43a08161afa365"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aae47701769042a62fb43a08161afa365">from_digits</a> (const std::vector&lt; unsigned int &gt; &amp;digits, unsigned int base=10)</td></tr>
<tr class="memdesc:aae47701769042a62fb43a08161afa365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of digits in the input base into an unsigned int.  <a href="namespacecannon_1_1math.html#aae47701769042a62fb43a08161afa365">More...</a><br /></td></tr>
<tr class="separator:aae47701769042a62fb43a08161afa365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81398259192f06aad778ed8461deef0a"><td class="memTemplParams" colspan="2"><a id="a81398259192f06aad778ed8461deef0a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81398259192f06aad778ed8461deef0a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_divisor_sum</b> (T x)</td></tr>
<tr class="separator:a81398259192f06aad778ed8461deef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e5852fe6b426a84eaaa5d34f25d8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a25e5852fe6b426a84eaaa5d34f25d8d2">bit_reverse</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:a25e5852fe6b426a84eaaa5d34f25d8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that swaps elements in the input array so that the indices of elements are bit-reversed.  <a href="namespacecannon_1_1math.html#a25e5852fe6b426a84eaaa5d34f25d8d2">More...</a><br /></td></tr>
<tr class="separator:a25e5852fe6b426a84eaaa5d34f25d8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6163e788a155d05efbe83888c8b04e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a7f6163e788a155d05efbe83888c8b04e">fft</a> (std::vector&lt; std::complex&lt; double &gt;&gt; data, bool inverse=false)</td></tr>
<tr class="memdesc:a7f6163e788a155d05efbe83888c8b04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes a Fast Fourier Transform or its inverse of the input data. If the inverse transform is requested, then the cyclic layout for frequence data suggested in Numerical Recipes pg. 612 is expected. Note that this is the lowest-level routine, so data should have a power of two length.  <a href="namespacecannon_1_1math.html#a7f6163e788a155d05efbe83888c8b04e">More...</a><br /></td></tr>
<tr class="separator:a7f6163e788a155d05efbe83888c8b04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f055b694ae7001074a56848f2df905"><td class="memTemplParams" colspan="2">template&lt;unsigned N, typename F , typename T &gt; </td></tr>
<tr class="memitem:a86f055b694ae7001074a56848f2df905"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcannon_1_1math_1_1nth__derivative.html">nth_derivative</a>&lt; F, T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a86f055b694ae7001074a56848f2df905">make_nth_derivative</a> (const F &amp;f, const T &amp;h)</td></tr>
<tr class="memdesc:a86f055b694ae7001074a56848f2df905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to create Nth derivative for an input real-valued function.  <a href="namespacecannon_1_1math.html#a86f055b694ae7001074a56848f2df905">More...</a><br /></td></tr>
<tr class="separator:a86f055b694ae7001074a56848f2df905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a720e8468d7263e22d4444959108950"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a7a720e8468d7263e22d4444959108950">rosenbrock</a> (const Vector2d &amp;x)</td></tr>
<tr class="memdesc:a7a720e8468d7263e22d4444959108950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the Rosenbrock function at the input point. See <a href="https://en.wikipedia.org/wiki/Rosenbrock_function">https://en.wikipedia.org/wiki/Rosenbrock_function</a>.  <a href="namespacecannon_1_1math.html#a7a720e8468d7263e22d4444959108950">More...</a><br /></td></tr>
<tr class="separator:a7a720e8468d7263e22d4444959108950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dd5b1682a4567ec0ee096b270d027"><td class="memItemLeft" align="right" valign="top">Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a8b9dd5b1682a4567ec0ee096b270d027">rosenbrock_grad</a> (const Vector2d &amp;x)</td></tr>
<tr class="memdesc:a8b9dd5b1682a4567ec0ee096b270d027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the Rosenbrock function at the input point.  <a href="namespacecannon_1_1math.html#a8b9dd5b1682a4567ec0ee096b270d027">More...</a><br /></td></tr>
<tr class="separator:a8b9dd5b1682a4567ec0ee096b270d027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53955632304e84d756e0af4ce4d7d9b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ad53955632304e84d756e0af4ce4d7d9b">cheb_points</a> (unsigned int num, double low=-1.0, double high=1.0)</td></tr>
<tr class="memdesc:ad53955632304e84d756e0af4ce4d7d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Chebyshev points between the input bounds. See <a href="https://en.wikipedia.org/wiki/Chebyshev_nodes">https://en.wikipedia.org/wiki/Chebyshev_nodes</a>.  <a href="namespacecannon_1_1math.html#ad53955632304e84d756e0af4ce4d7d9b">More...</a><br /></td></tr>
<tr class="separator:ad53955632304e84d756e0af4ce4d7d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c3ed0d673c6ef7512ddb5cbc79d1f8"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a24c3ed0d673c6ef7512ddb5cbc79d1f8">lagrange_interp</a> (std::function&lt; double(double)&gt; f, const std::vector&lt; double &gt; &amp;pts)</td></tr>
<tr class="memdesc:a24c3ed0d673c6ef7512ddb5cbc79d1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lagrange interpolant for the input function on the input points.  <a href="namespacecannon_1_1math.html#a24c3ed0d673c6ef7512ddb5cbc79d1f8">More...</a><br /></td></tr>
<tr class="separator:a24c3ed0d673c6ef7512ddb5cbc79d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9248f79acde95401f504978d18daab"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#acd9248f79acde95401f504978d18daab">lerp</a> (const Ref&lt; const VectorXd &gt; &amp;a, const Ref&lt; const VectorXd &gt; &amp;b, double t)</td></tr>
<tr class="memdesc:acd9248f79acde95401f504978d18daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate between the two input vectors.  <a href="namespacecannon_1_1math.html#acd9248f79acde95401f504978d18daab">More...</a><br /></td></tr>
<tr class="separator:acd9248f79acde95401f504978d18daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8940b00a971144de3fa48453e8f091ad"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a8940b00a971144de3fa48453e8f091ad">projection</a> (const Ref&lt; const VectorXd &gt; &amp;a, const Ref&lt; const VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:a8940b00a971144de3fa48453e8f091ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the projection of the first vector onto the second.  <a href="namespacecannon_1_1math.html#a8940b00a971144de3fa48453e8f091ad">More...</a><br /></td></tr>
<tr class="separator:a8940b00a971144de3fa48453e8f091ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812eb2968bcbc5e8c082298b1a160a2b"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a812eb2968bcbc5e8c082298b1a160a2b">complementary_projection</a> (const Ref&lt; const VectorXd &gt; &amp;a, const Ref&lt; const VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:a812eb2968bcbc5e8c082298b1a160a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complementary projection of the first vector with respect to the second.  <a href="namespacecannon_1_1math.html#a812eb2968bcbc5e8c082298b1a160a2b">More...</a><br /></td></tr>
<tr class="separator:a812eb2968bcbc5e8c082298b1a160a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad006f7740e9900ebdff2a63cf725b66b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VectorXu &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ad006f7740e9900ebdff2a63cf725b66b">make_lattice_points</a> (unsigned int dim, const VectorXu &amp;sizes)</td></tr>
<tr class="memdesc:ad006f7740e9900ebdff2a63cf725b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all lattice points on an integer-valued grid.  <a href="namespacecannon_1_1math.html#ad006f7740e9900ebdff2a63cf725b66b">More...</a><br /></td></tr>
<tr class="separator:ad006f7740e9900ebdff2a63cf725b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c2d096853a15ea77a1282ae1e00eee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VectorXu &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ac8c2d096853a15ea77a1282ae1e00eee">make_lattice_points</a> (const VectorXu &amp;sizes)</td></tr>
<tr class="memdesc:ac8c2d096853a15ea77a1282ae1e00eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all lattice points on an integer-valued grid.  <a href="namespacecannon_1_1math.html#ac8c2d096853a15ea77a1282ae1e00eee">More...</a><br /></td></tr>
<tr class="separator:ac8c2d096853a15ea77a1282ae1e00eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fca6f25597a09c6f4310d53dea6cc4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12fca6f25597a09c6f4310d53dea6cc4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_integer, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a12fca6f25597a09c6f4310d53dea6cc4">nearly_equal</a> (const T &amp;x, const T &amp;y, const T epsilon)</td></tr>
<tr class="memdesc:a12fca6f25597a09c6f4310d53dea6cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether two floating point numbers are nearly equal with respect to a tolerance parameter, and taking into account nonlinear floating-point mesh.  <a href="namespacecannon_1_1math.html#a12fca6f25597a09c6f4310d53dea6cc4">More...</a><br /></td></tr>
<tr class="separator:a12fca6f25597a09c6f4310d53dea6cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b045574def6f4c3797704952bb7d09"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a69b045574def6f4c3797704952bb7d09"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_integer, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a69b045574def6f4c3797704952bb7d09">nearly_equal</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a69b045574def6f4c3797704952bb7d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether two floating point numbers are nearly equal, taking into account nonlinear floating-point mesh.  <a href="namespacecannon_1_1math.html#a69b045574def6f4c3797704952bb7d09">More...</a><br /></td></tr>
<tr class="separator:a69b045574def6f4c3797704952bb7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae374290f7f085c0e14a3519a86e35be0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ae374290f7f085c0e14a3519a86e35be0">is_palindrome</a> (const std::vector&lt; unsigned int &gt; &amp;digits)</td></tr>
<tr class="memdesc:ae374290f7f085c0e14a3519a86e35be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the input number, represented as a vector of digits in some basis, is a palindrome.  <a href="namespacecannon_1_1math.html#ae374290f7f085c0e14a3519a86e35be0">More...</a><br /></td></tr>
<tr class="separator:ae374290f7f085c0e14a3519a86e35be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a237522f4b69f8e86ab197f23260a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aa1a237522f4b69f8e86ab197f23260a1">generate_palindromes_of_length</a> (unsigned int length, unsigned int base=10, bool outer=true)</td></tr>
<tr class="memdesc:aa1a237522f4b69f8e86ab197f23260a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate palindromes of exactly the input length in the given basis.  <a href="namespacecannon_1_1math.html#aa1a237522f4b69f8e86ab197f23260a1">More...</a><br /></td></tr>
<tr class="separator:aa1a237522f4b69f8e86ab197f23260a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263bda606953e09d00f889487612fdd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a1263bda606953e09d00f889487612fdd">generate_palindromes</a> (unsigned int max_length, unsigned int base=10)</td></tr>
<tr class="memdesc:a1263bda606953e09d00f889487612fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all palindromes with length up to the input maximum in a particular base.  <a href="namespacecannon_1_1math.html#a1263bda606953e09d00f889487612fdd">More...</a><br /></td></tr>
<tr class="separator:a1263bda606953e09d00f889487612fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f14044a7715a4b5a8066891eb699b20"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a2f14044a7715a4b5a8066891eb699b20">perlin_generate_perm</a> ()</td></tr>
<tr class="memdesc:a2f14044a7715a4b5a8066891eb699b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate permutation of noise.  <a href="namespacecannon_1_1math.html#a2f14044a7715a4b5a8066891eb699b20">More...</a><br /></td></tr>
<tr class="separator:a2f14044a7715a4b5a8066891eb699b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbf3401e0ee36ff3fea42551e2bf5a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a5fbf3401e0ee36ff3fea42551e2bf5a8">permute</a> (int *p, int n)</td></tr>
<tr class="memdesc:a5fbf3401e0ee36ff3fea42551e2bf5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the input int array of length n.  <a href="namespacecannon_1_1math.html#a5fbf3401e0ee36ff3fea42551e2bf5a8">More...</a><br /></td></tr>
<tr class="separator:a5fbf3401e0ee36ff3fea42551e2bf5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1388bc6e8094125c9ec7554665db48b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a1388bc6e8094125c9ec7554665db48b0">trilinear_interp</a> (double c[2][2][2], double u, double v, double w)</td></tr>
<tr class="memdesc:a1388bc6e8094125c9ec7554665db48b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trilinear interpolation of the input array.  <a href="namespacecannon_1_1math.html#a1388bc6e8094125c9ec7554665db48b0">More...</a><br /></td></tr>
<tr class="separator:a1388bc6e8094125c9ec7554665db48b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f291cff0a1ebe37d9200a7b03c31dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a22f291cff0a1ebe37d9200a7b03c31dc">trilinear_interp</a> (Vector3d c[2][2][2], double u, double v, double w)</td></tr>
<tr class="memdesc:a22f291cff0a1ebe37d9200a7b03c31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <a class="el" href="classcannon_1_1math_1_1Perlin.html" title="Class representing a perlin noise generator.">Perlin</a> trilinear interpolation of the input array.  <a href="namespacecannon_1_1math.html#a22f291cff0a1ebe37d9200a7b03c31dc">More...</a><br /></td></tr>
<tr class="separator:a22f291cff0a1ebe37d9200a7b03c31dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa832fde66e1040ede1a425d4a9041d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aaa832fde66e1040ede1a425d4a9041d7">hermitian_smooth</a> (double x)</td></tr>
<tr class="memdesc:aaa832fde66e1040ede1a425d4a9041d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform hermitian smoothing on the input.  <a href="namespacecannon_1_1math.html#aaa832fde66e1040ede1a425d4a9041d7">More...</a><br /></td></tr>
<tr class="separator:aaa832fde66e1040ede1a425d4a9041d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb92bc03e3e9e4c3cbd525b88e9c628"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bb92bc03e3e9e4c3cbd525b88e9c628"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, std::vector&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a7bb92bc03e3e9e4c3cbd525b88e9c628">get_primes_up_to</a> (T upper)</td></tr>
<tr class="memdesc:a7bb92bc03e3e9e4c3cbd525b88e9c628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all primes up to and including the input number. Uses the Sieve of Eratosthenes (<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>)  <a href="namespacecannon_1_1math.html#a7bb92bc03e3e9e4c3cbd525b88e9c628">More...</a><br /></td></tr>
<tr class="separator:a7bb92bc03e3e9e4c3cbd525b88e9c628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae12ae8c2694c01be3ea52514c8197a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ae12ae8c2694c01be3ea52514c8197a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a6ae12ae8c2694c01be3ea52514c8197a">is_prime</a> (T x)</td></tr>
<tr class="memdesc:a6ae12ae8c2694c01be3ea52514c8197a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the input number is prime. Note this is more efficient than simply running the Sieve of Eratosthenes and checking for inclusion.  <a href="namespacecannon_1_1math.html#a6ae12ae8c2694c01be3ea52514c8197a">More...</a><br /></td></tr>
<tr class="separator:a6ae12ae8c2694c01be3ea52514c8197a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05c95eed1c0d56f8bf160d22c46b5d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa05c95eed1c0d56f8bf160d22c46b5d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aa05c95eed1c0d56f8bf160d22c46b5d7">get_largest_prime_factor</a> (T n)</td></tr>
<tr class="memdesc:aa05c95eed1c0d56f8bf160d22c46b5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the largest prime factor of the input number. Returns the number itself if it's prime.  <a href="namespacecannon_1_1math.html#aa05c95eed1c0d56f8bf160d22c46b5d7">More...</a><br /></td></tr>
<tr class="separator:aa05c95eed1c0d56f8bf160d22c46b5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c0144f71372002022aa2d19ef6f29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa78c0144f71372002022aa2d19ef6f29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, std::multiset&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aa78c0144f71372002022aa2d19ef6f29">get_prime_factorization</a> (T n)</td></tr>
<tr class="memdesc:aa78c0144f71372002022aa2d19ef6f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get prime factorization of the input number.  <a href="namespacecannon_1_1math.html#aa78c0144f71372002022aa2d19ef6f29">More...</a><br /></td></tr>
<tr class="separator:aa78c0144f71372002022aa2d19ef6f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21a2e99ed1a303412b56061f43d15ae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ac21a2e99ed1a303412b56061f43d15ae">random_double</a> ()</td></tr>
<tr class="memdesc:ac21a2e99ed1a303412b56061f43d15ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random double uniformly at random between 0 and 1 in a thread-safe way.  <a href="namespacecannon_1_1math.html#ac21a2e99ed1a303412b56061f43d15ae">More...</a><br /></td></tr>
<tr class="separator:ac21a2e99ed1a303412b56061f43d15ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa01b03bc475a8b7e40322f2b521589"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a4fa01b03bc475a8b7e40322f2b521589">random_double</a> (double min, double max)</td></tr>
<tr class="memdesc:a4fa01b03bc475a8b7e40322f2b521589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random double between min and max.  <a href="namespacecannon_1_1math.html#a4fa01b03bc475a8b7e40322f2b521589">More...</a><br /></td></tr>
<tr class="separator:a4fa01b03bc475a8b7e40322f2b521589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83e9e266bafa31173c37cbf6381c270"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aa83e9e266bafa31173c37cbf6381c270">random_vec</a> ()</td></tr>
<tr class="memdesc:aa83e9e266bafa31173c37cbf6381c270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random vector with entries sampled uniformly at random between 0 and 1.  <a href="namespacecannon_1_1math.html#aa83e9e266bafa31173c37cbf6381c270">More...</a><br /></td></tr>
<tr class="separator:aa83e9e266bafa31173c37cbf6381c270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53db5e8d8dc07208153b5ac67d878c9"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#aa53db5e8d8dc07208153b5ac67d878c9">random_vec</a> (double min, double max)</td></tr>
<tr class="memdesc:aa53db5e8d8dc07208153b5ac67d878c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random vector with entries sampled uniformly at random between the input minimum and maximum.  <a href="namespacecannon_1_1math.html#aa53db5e8d8dc07208153b5ac67d878c9">More...</a><br /></td></tr>
<tr class="separator:aa53db5e8d8dc07208153b5ac67d878c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6bd92e8d57f2f7b6865706a32fe8e6"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a5a6bd92e8d57f2f7b6865706a32fe8e6">random_in_unit_sphere</a> ()</td></tr>
<tr class="memdesc:a5a6bd92e8d57f2f7b6865706a32fe8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random vector in the unit sphere.  <a href="namespacecannon_1_1math.html#a5a6bd92e8d57f2f7b6865706a32fe8e6">More...</a><br /></td></tr>
<tr class="separator:a5a6bd92e8d57f2f7b6865706a32fe8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e15332fa056efa71eca3154c1b28f8"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a59e15332fa056efa71eca3154c1b28f8">random_unit_vec</a> ()</td></tr>
<tr class="memdesc:a59e15332fa056efa71eca3154c1b28f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random unit vector.  <a href="namespacecannon_1_1math.html#a59e15332fa056efa71eca3154c1b28f8">More...</a><br /></td></tr>
<tr class="separator:a59e15332fa056efa71eca3154c1b28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aacb8958cf3d77f001ee36bd89e75e"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ae8aacb8958cf3d77f001ee36bd89e75e">random_in_hemisphere</a> (const Vector3d &amp;normal)</td></tr>
<tr class="memdesc:ae8aacb8958cf3d77f001ee36bd89e75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random vector in the unit hemisphere around the input normal vector.  <a href="namespacecannon_1_1math.html#ae8aacb8958cf3d77f001ee36bd89e75e">More...</a><br /></td></tr>
<tr class="separator:ae8aacb8958cf3d77f001ee36bd89e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20081304b7a6e8449ec3c291b9e0bc0b"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a20081304b7a6e8449ec3c291b9e0bc0b">random_in_disk</a> ()</td></tr>
<tr class="memdesc:a20081304b7a6e8449ec3c291b9e0bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random vector in the unit disk in the X-Y plane.  <a href="namespacecannon_1_1math.html#a20081304b7a6e8449ec3c291b9e0bc0b">More...</a><br /></td></tr>
<tr class="separator:a20081304b7a6e8449ec3c291b9e0bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128462410af2e6176546d536cceae4b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#a128462410af2e6176546d536cceae4b5">bisection_method</a> (std::function&lt; double(double)&gt; f, double a, double b, unsigned int iters=100)</td></tr>
<tr class="memdesc:a128462410af2e6176546d536cceae4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an approximate root of the input function using the bisection method. See <a href="https://en.wikipedia.org/wiki/Bisection_method">https://en.wikipedia.org/wiki/Bisection_method</a>.  <a href="namespacecannon_1_1math.html#a128462410af2e6176546d536cceae4b5">More...</a><br /></td></tr>
<tr class="separator:a128462410af2e6176546d536cceae4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54d59e921c4390e9d827f9c60d4ea09"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ac54d59e921c4390e9d827f9c60d4ea09">regula_falsi</a> (std::function&lt; double(double)&gt; f, double a, double b, unsigned int iters=100)</td></tr>
<tr class="memdesc:ac54d59e921c4390e9d827f9c60d4ea09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an approximate root of the input function using the Regula Falsi method. Note this is a bracketing method.  <a href="namespacecannon_1_1math.html#ac54d59e921c4390e9d827f9c60d4ea09">More...</a><br /></td></tr>
<tr class="separator:ac54d59e921c4390e9d827f9c60d4ea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64029991c025b04471f35e89d4d534e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#af64029991c025b04471f35e89d4d534e">newton_method</a> (std::function&lt; double(double)&gt; f, std::function&lt; double(double)&gt; fdot, double start, unsigned int iters=100)</td></tr>
<tr class="memdesc:af64029991c025b04471f35e89d4d534e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an approximate root of the input function using Newton's method.  <a href="namespacecannon_1_1math.html#af64029991c025b04471f35e89d4d534e">More...</a><br /></td></tr>
<tr class="separator:af64029991c025b04471f35e89d4d534e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf1fbe248ec315cc4020f7b5802785a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#abaf1fbe248ec315cc4020f7b5802785a">compute_decimal_reciprocal</a> (unsigned int x)</td></tr>
<tr class="memdesc:abaf1fbe248ec315cc4020f7b5802785a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exact decimal representation of the reciprocal of the input integer. All reciprocals are between 0 and 1, exclusive.  <a href="namespacecannon_1_1math.html#abaf1fbe248ec315cc4020f7b5802785a">More...</a><br /></td></tr>
<tr class="separator:abaf1fbe248ec315cc4020f7b5802785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad773741e58ec1604612c618ddd16cee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1math.html#ad773741e58ec1604612c618ddd16cee9">print_decimal_reciprocal</a> (unsigned int x)</td></tr>
<tr class="memdesc:ad773741e58ec1604612c618ddd16cee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the exact decimal representation of the reciprocal of the input integer, in the format.  <a href="namespacecannon_1_1math.html#ad773741e58ec1604612c618ddd16cee9">More...</a><br /></td></tr>
<tr class="separator:ad773741e58ec1604612c618ddd16cee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing mathematical utilities. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a128462410af2e6176546d536cceae4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128462410af2e6176546d536cceae4b5">&#9670;&nbsp;</a></span>bisection_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::bisection_method </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iters</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an approximate root of the input function using the bisection method. See <a href="https://en.wikipedia.org/wiki/Bisection_method">https://en.wikipedia.org/wiki/Bisection_method</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to find a root of </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of interval </td></tr>
    <tr><td class="paramname">iters</td><td>Maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximate root of the function in the interval [a, b]. </dd></dl>

</div>
</div>
<a id="a25e5852fe6b426a84eaaa5d34f25d8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e5852fe6b426a84eaaa5d34f25d8d2">&#9670;&nbsp;</a></span>bit_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::math::bit_reverse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that swaps elements in the input array so that the indices of elements are bit-reversed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to rearrange in bit-reversed order. Will be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad53955632304e84d756e0af4ce4d7d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53955632304e84d756e0af4ce4d7d9b">&#9670;&nbsp;</a></span>cheb_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cannon::math::cheb_points </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>low</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>high</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Chebyshev points between the input bounds. See <a href="https://en.wikipedia.org/wiki/Chebyshev_nodes">https://en.wikipedia.org/wiki/Chebyshev_nodes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">low</td><td>Lower limit for points </td></tr>
    <tr><td class="paramname">high</td><td>Upper limit for points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the Chebyshev points. </dd></dl>

</div>
</div>
<a id="a812eb2968bcbc5e8c082298b1a160a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812eb2968bcbc5e8c082298b1a160a2b">&#9670;&nbsp;</a></span>complementary_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd cannon::math::complementary_projection </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the complementary projection of the first vector with respect to the second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector to be projected </td></tr>
    <tr><td class="paramname">b</td><td>The vector that projection is computed with respect to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary projection. </dd></dl>

</div>
</div>
<a id="add24a42e434bcecb5e6533ff35ed7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add24a42e434bcecb5e6533ff35ed7cdb">&#9670;&nbsp;</a></span>compute_barycentric_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::compute_barycentric_coords </td>
          <td>(</td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute barycentric coordinates for a query point on triangle defined by its three vertices. See <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>First vertex </td></tr>
    <tr><td class="paramname">v1</td><td>Second vertex </td></tr>
    <tr><td class="paramname">v2</td><td>Third vertex </td></tr>
    <tr><td class="paramname">p</td><td>Query point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Barycentric coordinates for the query point. </dd></dl>

</div>
</div>
<a id="abaf1fbe248ec315cc4020f7b5802785a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf1fbe248ec315cc4020f7b5802785a">&#9670;&nbsp;</a></span>compute_decimal_reciprocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt; cannon::math::compute_decimal_reciprocal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the exact decimal representation of the reciprocal of the input integer. All reciprocals are between 0 and 1, exclusive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The integer to compute reciprocal of. Should be &gt;= 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors in which the first is a vector of non-repeating digits and the second is a vector of repeating digits. </dd></dl>

</div>
</div>
<a id="a7f6163e788a155d05efbe83888c8b04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6163e788a155d05efbe83888c8b04e">&#9670;&nbsp;</a></span>fft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; double &gt; &gt; cannon::math::fft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that computes a Fast Fourier Transform or its inverse of the input data. If the inverse transform is requested, then the cyclic layout for frequence data suggested in Numerical Recipes pg. 612 is expected. Note that this is the lowest-level routine, so data should have a power of two length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The sampled time series or frequency data to transform. Should have length that is a power of two. </td></tr>
    <tr><td class="paramname">inverse</td><td>Whether to compute the forward or inverse transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed data. </dd></dl>

</div>
</div>
<a id="aae47701769042a62fb43a08161afa365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae47701769042a62fb43a08161afa365">&#9670;&nbsp;</a></span>from_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cannon::math::from_digits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector of digits in the input base into an unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digits</td><td>The digits </td></tr>
    <tr><td class="paramname">base</td><td>The base that the digits are in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An equivalent unsigned int </dd></dl>

</div>
</div>
<a id="a1263bda606953e09d00f889487612fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263bda606953e09d00f889487612fdd">&#9670;&nbsp;</a></span>generate_palindromes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; cannon::math::generate_palindromes </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all palindromes with length up to the input maximum in a particular base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_length</td><td>Maximum length of palindromes to generate. </td></tr>
    <tr><td class="paramname">base</td><td>Base in which to generate palindromes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of all palindromes up to the input length. </dd></dl>

</div>
</div>
<a id="aa1a237522f4b69f8e86ab197f23260a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a237522f4b69f8e86ab197f23260a1">&#9670;&nbsp;</a></span>generate_palindromes_of_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; cannon::math::generate_palindromes_of_length </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate palindromes of exactly the input length in the given basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Length of palindromes to generate. </td></tr>
    <tr><td class="paramname">base</td><td>Base in which to generate palindromes. </td></tr>
    <tr><td class="paramname">outer</td><td>Whether this is the first call of this function in a recursive stack. Used to prevent leading zeros.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of palindromes of the input length. </dd></dl>

</div>
</div>
<a id="a8f81691b6e6b2b0ce10bc775aab264fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f81691b6e6b2b0ce10bc775aab264fd">&#9670;&nbsp;</a></span>get_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; cannon::math::get_digits </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector of digits of the input number in the input base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to get digits of. </td></tr>
    <tr><td class="paramname">base</td><td>The base to get digits in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the digits of x, where the digit at index 0 is the digit occupying the "0s place" in the number. In other words, x can be recovered as base^0 * digits[0] + ... + base^(digits.size() - 1) * digits[digits.size() - 1]. </dd></dl>

</div>
</div>
<a id="aa05c95eed1c0d56f8bf160d22c46b5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05c95eed1c0d56f8bf160d22c46b5d7">&#9670;&nbsp;</a></span>get_largest_prime_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type cannon::math::get_largest_prime_factor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the largest prime factor of the input number. Returns the number itself if it's prime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number to get the largest prime factor of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest prime factor. </dd></dl>

</div>
</div>
<a id="aa78c0144f71372002022aa2d19ef6f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78c0144f71372002022aa2d19ef6f29">&#9670;&nbsp;</a></span>get_prime_factorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, std::multiset&lt;T&gt; &gt;::type cannon::math::get_prime_factorization </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get prime factorization of the input number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number to factorize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A multiset of prime factors, where the number of entries for a particular prime is the number of times that the prime occurs in the prime factorization. </dd></dl>

</div>
</div>
<a id="a7bb92bc03e3e9e4c3cbd525b88e9c628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb92bc03e3e9e4c3cbd525b88e9c628">&#9670;&nbsp;</a></span>get_primes_up_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, std::vector&lt;T&gt; &gt;::type cannon::math::get_primes_up_to </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all primes up to and including the input number. Uses the Sieve of Eratosthenes (<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a>) </p>
<p>Templated to work for all integral types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper</td><td>Upper limit for prime finding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the primes up to upper, sorted in increasing order. </dd></dl>

</div>
</div>
<a id="aaa832fde66e1040ede1a425d4a9041d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa832fde66e1040ede1a425d4a9041d7">&#9670;&nbsp;</a></span>hermitian_smooth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::hermitian_smooth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform hermitian smoothing on the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hermitian smoothed input. </dd></dl>

</div>
</div>
<a id="ae374290f7f085c0e14a3519a86e35be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae374290f7f085c0e14a3519a86e35be0">&#9670;&nbsp;</a></span>is_palindrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cannon::math::is_palindrome </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the input number, represented as a vector of digits in some basis, is a palindrome. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="digits_8hpp.html" title="File containing utilities for working with digit representations of numbers in various bases.">cannon/math/digits.hpp</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digits</td><td>The digits of the number to check for being a palindrome.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the input digits are palindromic. </dd></dl>

</div>
</div>
<a id="a6ae12ae8c2694c01be3ea52514c8197a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae12ae8c2694c01be3ea52514c8197a">&#9670;&nbsp;</a></span>is_prime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::type cannon::math::is_prime </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the input number is prime. Note this is more efficient than simply running the Sieve of Eratosthenes and checking for inclusion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to check for primeness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24c3ed0d673c6ef7512ddb5cbc79d1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c3ed0d673c6ef7512ddb5cbc79d1f8">&#9670;&nbsp;</a></span>lagrange_interp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; double(double)&gt; cannon::math::lagrange_interp </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Lagrange interpolant for the input function on the input points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate. </td></tr>
    <tr><td class="paramname">pts</td><td>The points to interpolate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Lagrange interpolating polynomial on the input points. </dd></dl>

</div>
</div>
<a id="acd9248f79acde95401f504978d18daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9248f79acde95401f504978d18daab">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd cannon::math::lerp </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate between the two input vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First vector </td></tr>
    <tr><td class="paramname">b</td><td>Second vector </td></tr>
    <tr><td class="paramname">t</td><td>Interpolation amount. Should be between 0 and 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolated vector. </dd></dl>

</div>
</div>
<a id="ac8c2d096853a15ea77a1282ae1e00eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c2d096853a15ea77a1282ae1e00eee">&#9670;&nbsp;</a></span>make_lattice_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VectorXu&gt; cannon::math::make_lattice_points </td>
          <td>(</td>
          <td class="paramtype">const VectorXu &amp;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all lattice points on an integer-valued grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Number of elements in each dimension of the grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lattice points for the grid. </dd></dl>

</div>
</div>
<a id="ad006f7740e9900ebdff2a63cf725b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad006f7740e9900ebdff2a63cf725b66b">&#9670;&nbsp;</a></span>make_lattice_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VectorXu&gt; cannon::math::make_lattice_points </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXu &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all lattice points on an integer-valued grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Which dimension of the lattice to generate. </td></tr>
    <tr><td class="paramname">sizes</td><td>Number of elements in each dimension of the grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lattice points for dimensions 0 through dim-1 </dd></dl>

</div>
</div>
<a id="a86f055b694ae7001074a56848f2df905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f055b694ae7001074a56848f2df905">&#9670;&nbsp;</a></span>make_nth_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcannon_1_1math_1_1nth__derivative.html">nth_derivative</a>&lt;F, T, N&gt; cannon::math::make_nth_derivative </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to create Nth derivative for an input real-valued function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to take a derivative of. </td></tr>
    <tr><td class="paramname">h</td><td>Amount to add for finite differencing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object representing the Nth derivative of the input function. </dd></dl>

</div>
</div>
<a id="a69b045574def6f4c3797704952bb7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b045574def6f4c3797704952bb7d09">&#9670;&nbsp;</a></span>nearly_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::numeric_limits&lt;T&gt;::is_integer, bool&gt;::type cannon::math::nearly_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether two floating point numbers are nearly equal, taking into account nonlinear floating-point mesh. </p>
<p>Adapted from <a href="https://floating-point-gui.de/errors/comparison/">https://floating-point-gui.de/errors/comparison/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First number to compare </td></tr>
    <tr><td class="paramname">y</td><td>Second number to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the input floats are nearly equal. </dd></dl>

</div>
</div>
<a id="a12fca6f25597a09c6f4310d53dea6cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fca6f25597a09c6f4310d53dea6cc4">&#9670;&nbsp;</a></span>nearly_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::numeric_limits&lt;T&gt;::is_integer, bool&gt;::type cannon::math::nearly_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether two floating point numbers are nearly equal with respect to a tolerance parameter, and taking into account nonlinear floating-point mesh. </p>
<p>Adapted from <a href="https://floating-point-gui.de/errors/comparison/">https://floating-point-gui.de/errors/comparison/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First number to compare </td></tr>
    <tr><td class="paramname">y</td><td>Second number to compare </td></tr>
    <tr><td class="paramname">epsilon</td><td>Tolerance parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the input floats are nearly equal. </dd></dl>

</div>
</div>
<a id="af64029991c025b04471f35e89d4d534e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64029991c025b04471f35e89d4d534e">&#9670;&nbsp;</a></span>newton_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::newton_method </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>fdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iters</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an approximate root of the input function using Newton's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to find a root of </td></tr>
    <tr><td class="paramname">fdot</td><td>The derivative of f </td></tr>
    <tr><td class="paramname">start</td><td>Initial value for to being iterating from </td></tr>
    <tr><td class="paramname">iters</td><td>Maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f14044a7715a4b5a8066891eb699b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f14044a7715a4b5a8066891eb699b20">&#9670;&nbsp;</a></span>perlin_generate_perm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * cannon::math::perlin_generate_perm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate permutation of noise. </p>
<dl class="section return"><dt>Returns</dt><dd>Permutation of length <a class="el" href="classcannon_1_1math_1_1Perlin.html#a4751e6537038661bdebba126b883702f" title="Number of random floats to generate.">Perlin::point_count_</a>; </dd></dl>

</div>
</div>
<a id="a5fbf3401e0ee36ff3fea42551e2bf5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbf3401e0ee36ff3fea42551e2bf5a8">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::math::permute </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute the input int array of length n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The array to permute. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the input array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad773741e58ec1604612c618ddd16cee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad773741e58ec1604612c618ddd16cee9">&#9670;&nbsp;</a></span>print_decimal_reciprocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::math::print_decimal_reciprocal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the exact decimal representation of the reciprocal of the input integer, in the format. </p>
<p>0.x(y)</p>
<p>where x is the non-repeating digits of the decimal and y is the recurring digits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to print the decimal reciprocal of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8940b00a971144de3fa48453e8f091ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8940b00a971144de3fa48453e8f091ad">&#9670;&nbsp;</a></span>projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd cannon::math::projection </td>
          <td>(</td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref&lt; const VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the projection of the first vector onto the second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The vector to be projected </td></tr>
    <tr><td class="paramname">b</td><td>The vector that projection is computed with respect to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected vector. </dd></dl>

</div>
</div>
<a id="ac21a2e99ed1a303412b56061f43d15ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21a2e99ed1a303412b56061f43d15ae">&#9670;&nbsp;</a></span>random_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::random_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random double uniformly at random between 0 and 1 in a thread-safe way. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated double. </dd></dl>

</div>
</div>
<a id="a4fa01b03bc475a8b7e40322f2b521589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa01b03bc475a8b7e40322f2b521589">&#9670;&nbsp;</a></span>random_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::random_double </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random double between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum number that can be generated. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum number that can be generated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated double. </dd></dl>

</div>
</div>
<a id="a20081304b7a6e8449ec3c291b9e0bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20081304b7a6e8449ec3c291b9e0bc0b">&#9670;&nbsp;</a></span>random_in_disk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_in_disk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random vector in the unit disk in the X-Y plane. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="ae8aacb8958cf3d77f001ee36bd89e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8aacb8958cf3d77f001ee36bd89e75e">&#9670;&nbsp;</a></span>random_in_hemisphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_in_hemisphere </td>
          <td>(</td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random vector in the unit hemisphere around the input normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>The normal vector to sample around.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="a5a6bd92e8d57f2f7b6865706a32fe8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6bd92e8d57f2f7b6865706a32fe8e6">&#9670;&nbsp;</a></span>random_in_unit_sphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_in_unit_sphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random vector in the unit sphere. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="a59e15332fa056efa71eca3154c1b28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e15332fa056efa71eca3154c1b28f8">&#9670;&nbsp;</a></span>random_unit_vec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_unit_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random unit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="aa83e9e266bafa31173c37cbf6381c270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83e9e266bafa31173c37cbf6381c270">&#9670;&nbsp;</a></span>random_vec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random vector with entries sampled uniformly at random between 0 and 1. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="aa53db5e8d8dc07208153b5ac67d878c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53db5e8d8dc07208153b5ac67d878c9">&#9670;&nbsp;</a></span>random_vec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d cannon::math::random_vec </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random vector with entries sampled uniformly at random between the input minimum and maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum value to generate. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value to generate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated vector. </dd></dl>

</div>
</div>
<a id="ac54d59e921c4390e9d827f9c60d4ea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54d59e921c4390e9d827f9c60d4ea09">&#9670;&nbsp;</a></span>regula_falsi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::regula_falsi </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iters</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an approximate root of the input function using the Regula Falsi method. Note this is a bracketing method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to find a root of </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of interval </td></tr>
    <tr><td class="paramname">iters</td><td>Maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximate root of the function in the interval [a, b]. </dd></dl>

</div>
</div>
<a id="a7a720e8468d7263e22d4444959108950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a720e8468d7263e22d4444959108950">&#9670;&nbsp;</a></span>rosenbrock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::rosenbrock </td>
          <td>(</td>
          <td class="paramtype">const Vector2d &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value of the Rosenbrock function at the input point. See <a href="https://en.wikipedia.org/wiki/Rosenbrock_function">https://en.wikipedia.org/wiki/Rosenbrock_function</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The point at which to evaluate the Rosenbrock function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the Rosenbrock function at the input point. </dd></dl>

</div>
</div>
<a id="a8b9dd5b1682a4567ec0ee096b270d027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9dd5b1682a4567ec0ee096b270d027">&#9670;&nbsp;</a></span>rosenbrock_grad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2d cannon::math::rosenbrock_grad </td>
          <td>(</td>
          <td class="paramtype">const Vector2d &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the Rosenbrock function at the input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The point at which to compute the gradient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rosenbrock function gradient at the input point. </dd></dl>

</div>
</div>
<a id="a1388bc6e8094125c9ec7554665db48b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1388bc6e8094125c9ec7554665db48b0">&#9670;&nbsp;</a></span>trilinear_interp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::trilinear_interp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>[2][2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute trilinear interpolation of the input array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Array to interpolate. </td></tr>
    <tr><td class="paramname">u</td><td>First interpolation coefficient. </td></tr>
    <tr><td class="paramname">v</td><td>Second interpolation coefficient. </td></tr>
    <tr><td class="paramname">w</td><td>Third interpolation coefficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolant. </dd></dl>

</div>
</div>
<a id="a22f291cff0a1ebe37d9200a7b03c31dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f291cff0a1ebe37d9200a7b03c31dc">&#9670;&nbsp;</a></span>trilinear_interp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::math::trilinear_interp </td>
          <td>(</td>
          <td class="paramtype">Vector3d&#160;</td>
          <td class="paramname"><em>c</em>[2][2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <a class="el" href="classcannon_1_1math_1_1Perlin.html" title="Class representing a perlin noise generator.">Perlin</a> trilinear interpolation of the input array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Array to interpolate. </td></tr>
    <tr><td class="paramname">u</td><td>First interpolation coefficient. </td></tr>
    <tr><td class="paramname">v</td><td>Second interpolation coefficient. </td></tr>
    <tr><td class="paramname">w</td><td>Third interpolation coefficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolant. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cannon</b></li><li class="navelem"><a class="el" href="namespacecannon_1_1math.html">math</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
