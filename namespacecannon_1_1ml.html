<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cannon: cannon::ml Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cannon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecannon_1_1ml.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cannon::ml Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing various optimization and learning algorithms.  
<a href="namespacecannon_1_1ml.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1AdamOptimizer.html">AdamOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an Adam optimizer. Adam is a stochastic optimization method which produces modified stochastic gradients by estimating the moments of the distribution of stochastic gradients. See <a href="https://arxiv.org/abs/1412.6980">https://arxiv.org/abs/1412.6980</a>.  <a href="classcannon_1_1ml_1_1AdamOptimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1BFGSOptimizer.html">BFGSOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a BFGS optimizer, which is a quasi-Newton unconstrained optimization method for nonlinear problems. See <a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm</a>.  <a href="classcannon_1_1ml_1_1BFGSOptimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1OptimizationResult.html">OptimizationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the result of an optimization attempt.  <a href="classcannon_1_1ml_1_1OptimizationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1PatternSearchOptimizer.html">PatternSearchOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a pattern search optimizer. Pattern Search is a derivative-free optimization method, similar to the Nelder-Mead method but with better convergence guarantees. See <a href="https://en.wikipedia.org/wiki/Pattern_search_(optimization)">https://en.wikipedia.org/wiki/Pattern_search_(optimization)</a>.  <a href="classcannon_1_1ml_1_1PatternSearchOptimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1PiecewiseILSTDFilter.html">PiecewiseILSTDFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a Least-Squares Temporal Difference (LSTD) approximator using a feature set that produces a piecewise-affine value function approximation. This is for use in reinforcement learning algorithms. This version of the algorithm follows the incremental LSTD algorithm detailed in .  <a href="classcannon_1_1ml_1_1PiecewiseILSTDFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1PiecewiseLSTDFilter.html">PiecewiseLSTDFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a Least-Squares Temporal Difference (LSTD) approximator using a feature set that produces a piecewise-affine value function approximation. This is for use in reinforcement learning algorithms.  <a href="classcannon_1_1ml_1_1PiecewiseLSTDFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1PiecewiseRecursiveLSTDFilter.html">PiecewiseRecursiveLSTDFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a Least-Squares Temporal Difference (LSTD) approximator using a feature set that produces a piecewise-affine value function approximation. This is for use in reinforcement learning algorithms. This version of the algorithm is similar to a recursive least squares filter.  <a href="classcannon_1_1ml_1_1PiecewiseRecursiveLSTDFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1ml_1_1RLSFilter.html">RLSFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a Recursive Least Squares Filter supporting intercept estimation and forgetting. See <a href="http://cannontwo.com/assets/rls_notes.pdf">http://cannontwo.com/assets/rls_notes.pdf</a>.  <a href="classcannon_1_1ml_1_1RLSFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7d55455a70c79ad5f6cdb89a11c1ce30"><td class="memItemLeft" align="right" valign="top"><a id="a7d55455a70c79ad5f6cdb89a11c1ce30"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#a7d55455a70c79ad5f6cdb89a11c1ce30">LloydSamplingStrategy</a> { <b>Grid</b>, 
<b>Uniform</b>
 }</td></tr>
<tr class="memdesc:a7d55455a70c79ad5f6cdb89a11c1ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class representing the different ways that the centroid integral used by Lloyd's algorithm can be numerically approximated. <br /></td></tr>
<tr class="separator:a7d55455a70c79ad5f6cdb89a11c1ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab4315ee88e543673f4e1626cf683808"><td class="memItemLeft" align="right" valign="top"><a id="aab4315ee88e543673f4e1626cf683808"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CANNON_CLASS_FORWARD</b> (<a class="el" href="classcannon_1_1ml_1_1OptimizationResult.html">OptimizationResult</a>)</td></tr>
<tr class="separator:aab4315ee88e543673f4e1626cf683808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab240ee96acec64da1aa9720f79d83f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#ab240ee96acec64da1aa9720f79d83f39">do_lloyd_iteration</a> (Matrix2Xd &amp;pts, <a class="el" href="namespacecannon_1_1ml.html#a7d55455a70c79ad5f6cdb89a11c1ce30">LloydSamplingStrategy</a> strat=LloydSamplingStrategy::Grid, double x_low=-1.0, double x_high=1.0, double y_low=-1.0, double y_high=1.0)</td></tr>
<tr class="memdesc:ab240ee96acec64da1aa9720f79d83f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute a single iteration of the classic Lloyd's algorithm in place within the specified bounds.  <a href="namespacecannon_1_1ml.html#ab240ee96acec64da1aa9720f79d83f39">More...</a><br /></td></tr>
<tr class="separator:ab240ee96acec64da1aa9720f79d83f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0ef2d700b61e4b6364708e5ff757c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#a6e0ef2d700b61e4b6364708e5ff757c4">do_lloyd_iteration</a> (Matrix2Xd &amp;pts, std::function&lt; double(const Vector2d &amp;)&gt; f, <a class="el" href="namespacecannon_1_1ml.html#a7d55455a70c79ad5f6cdb89a11c1ce30">LloydSamplingStrategy</a> strat=LloydSamplingStrategy::Grid, double x_low=-1.0, double x_high=1.0, double y_low=-1.0, double y_high=1.0)</td></tr>
<tr class="memdesc:a6e0ef2d700b61e4b6364708e5ff757c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute a single iteration of Lloyd's algorithm with respect to the input weighting function in place within the specified bounds.  <a href="namespacecannon_1_1ml.html#a6e0ef2d700b61e4b6364708e5ff757c4">More...</a><br /></td></tr>
<tr class="separator:a6e0ef2d700b61e4b6364708e5ff757c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce009595395a0d14cbecd0ded1af8cc"><td class="memItemLeft" align="right" valign="top"><a id="a8ce009595395a0d14cbecd0ded1af8cc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="classcannon_1_1ml_1_1OptimizationResult.html">OptimizationResult</a> result)</td></tr>
<tr class="separator:a8ce009595395a0d14cbecd0ded1af8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7281dadd82cc193b46cd01821a169"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#ac0d7281dadd82cc193b46cd01821a169">sufficient_decrease_condition</a> (RealFunc f, MultiFunc f_grad, const VectorXd &amp;x, double step, const VectorXd &amp;direction, double c_1)</td></tr>
<tr class="memdesc:ac0d7281dadd82cc193b46cd01821a169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the input step along the input direction satisfies the Armijo sufficient decrease condition with respect to the function under consideration.  <a href="namespacecannon_1_1ml.html#ac0d7281dadd82cc193b46cd01821a169">More...</a><br /></td></tr>
<tr class="separator:ac0d7281dadd82cc193b46cd01821a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f9ce214e2dbc383fcce4d501842ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#aa5f9ce214e2dbc383fcce4d501842ce8">curvature_condition</a> (RealFunc f, MultiFunc f_grad, const VectorXd &amp;x, double step, const VectorXd &amp;direction, double c_2)</td></tr>
<tr class="memdesc:aa5f9ce214e2dbc383fcce4d501842ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the input step along the input direction satisfies the curvature condition.  <a href="namespacecannon_1_1ml.html#aa5f9ce214e2dbc383fcce4d501842ce8">More...</a><br /></td></tr>
<tr class="separator:aa5f9ce214e2dbc383fcce4d501842ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66585f51a99a678498d34bbea0d7cf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#a66585f51a99a678498d34bbea0d7cf47">wolfe_conditions</a> (RealFunc f, MultiFunc f_grad, const VectorXd &amp;x, double step, const VectorXd &amp;direction, double c_1, double c_2)</td></tr>
<tr class="memdesc:a66585f51a99a678498d34bbea0d7cf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether both Wolfe conditions are satisfied by the input step along the input direction.  <a href="namespacecannon_1_1ml.html#a66585f51a99a678498d34bbea0d7cf47">More...</a><br /></td></tr>
<tr class="separator:a66585f51a99a678498d34bbea0d7cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8d7e02f826d58688d53ba8959bebd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#a5ac8d7e02f826d58688d53ba8959bebd">line_search_zoom</a> (RealFunc f, MultiFunc f_grad, const VectorXd &amp;x, const VectorXd &amp;direction, double start_low, double start_high, double c_1, double c_2, unsigned int iterations=100)</td></tr>
<tr class="memdesc:a5ac8d7e02f826d58688d53ba8959bebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal line search step between the input minimum and maximum along the input direction. Note that this is the minimizing step.  <a href="namespacecannon_1_1ml.html#a5ac8d7e02f826d58688d53ba8959bebd">More...</a><br /></td></tr>
<tr class="separator:a5ac8d7e02f826d58688d53ba8959bebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9547572106b1cc75347e60783441cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecannon_1_1ml.html#ade9547572106b1cc75347e60783441cb">wolfe_condition_line_search</a> (RealFunc f, MultiFunc f_grad, const VectorXd &amp;x, const VectorXd &amp;direction, double step_1=1.0, double c_1=1e-4, double c_2=0.5, unsigned int iterations=100)</td></tr>
<tr class="memdesc:ade9547572106b1cc75347e60783441cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal line search step along the input direction, moving as far as possible while satisfying the Wolfe conditions. Note that this is the minimizing step.  <a href="namespacecannon_1_1ml.html#ade9547572106b1cc75347e60783441cb">More...</a><br /></td></tr>
<tr class="separator:ade9547572106b1cc75347e60783441cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing various optimization and learning algorithms. </p>
<p>; ML, or Machine Learning, is being used as an umbrella term here to suggest that everything in this namespace has some relationship to optimizing function approximations using data, but many of these methods are not, strictly speaking, machine learning methods. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa5f9ce214e2dbc383fcce4d501842ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f9ce214e2dbc383fcce4d501842ce8">&#9670;&nbsp;</a></span>curvature_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cannon::ml::curvature_condition </td>
          <td>(</td>
          <td class="paramtype">RealFunc&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiFunc&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether the input step along the input direction satisfies the curvature condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function being optimized </td></tr>
    <tr><td class="paramname">f_grad</td><td>Gradient of the function being optimized </td></tr>
    <tr><td class="paramname">x</td><td>Current state from which to compute sufficient decrease </td></tr>
    <tr><td class="paramname">step</td><td>Step along direction from x </td></tr>
    <tr><td class="paramname">direction</td><td>Optimization direction </td></tr>
    <tr><td class="paramname">c_2</td><td>Curvature parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab240ee96acec64da1aa9720f79d83f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab240ee96acec64da1aa9720f79d83f39">&#9670;&nbsp;</a></span>do_lloyd_iteration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::ml::do_lloyd_iteration </td>
          <td>(</td>
          <td class="paramtype">Matrix2Xd &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecannon_1_1ml.html#a7d55455a70c79ad5f6cdb89a11c1ce30">LloydSamplingStrategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code>LloydSamplingStrategy::Grid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_low</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_high</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_low</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_high</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute a single iteration of the classic Lloyd's algorithm in place within the specified bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>The current points making up the Voronoi diagram. </td></tr>
    <tr><td class="paramname">strat</td><td>Sampling strategy to use for approximating centroid </td></tr>
    <tr><td class="paramname">x_low</td><td>X axis lower bound </td></tr>
    <tr><td class="paramname">x_high</td><td>X axis upper bound </td></tr>
    <tr><td class="paramname">y_low</td><td>Y axis lower bound </td></tr>
    <tr><td class="paramname">y_high</td><td>Y axis upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e0ef2d700b61e4b6364708e5ff757c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0ef2d700b61e4b6364708e5ff757c4">&#9670;&nbsp;</a></span>do_lloyd_iteration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cannon::ml::do_lloyd_iteration </td>
          <td>(</td>
          <td class="paramtype">Matrix2Xd &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(const Vector2d &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecannon_1_1ml.html#a7d55455a70c79ad5f6cdb89a11c1ce30">LloydSamplingStrategy</a>&#160;</td>
          <td class="paramname"><em>strat</em> = <code>LloydSamplingStrategy::Grid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_low</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_high</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_low</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_high</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute a single iteration of Lloyd's algorithm with respect to the input weighting function in place within the specified bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>The current points making up the Voronoi diagram. </td></tr>
    <tr><td class="paramname">f</td><td>The weighting function to use. Should be everywhere positive. </td></tr>
    <tr><td class="paramname">strat</td><td>Sampling strategy to use for approximating centroid </td></tr>
    <tr><td class="paramname">x_low</td><td>X axis lower bound </td></tr>
    <tr><td class="paramname">x_high</td><td>X axis upper bound </td></tr>
    <tr><td class="paramname">y_low</td><td>Y axis lower bound </td></tr>
    <tr><td class="paramname">y_high</td><td>Y axis upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac8d7e02f826d58688d53ba8959bebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac8d7e02f826d58688d53ba8959bebd">&#9670;&nbsp;</a></span>line_search_zoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::ml::line_search_zoom </td>
          <td>(</td>
          <td class="paramtype">RealFunc&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiFunc&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the optimal line search step between the input minimum and maximum along the input direction. Note that this is the minimizing step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be minimized. </td></tr>
    <tr><td class="paramname">f_grad</td><td>Gradient function for the function to be minimized. </td></tr>
    <tr><td class="paramname">x</td><td>State to conduct line search from </td></tr>
    <tr><td class="paramname">direction</td><td>Direction for line search </td></tr>
    <tr><td class="paramname">start_low</td><td>Initial minimal step </td></tr>
    <tr><td class="paramname">start_high</td><td>Initial maximal step </td></tr>
    <tr><td class="paramname">c_1</td><td>Sufficient decrease parameter </td></tr>
    <tr><td class="paramname">c_2</td><td>Curvature parameter </td></tr>
    <tr><td class="paramname">iterations</td><td>Maximum number of iterations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0d7281dadd82cc193b46cd01821a169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d7281dadd82cc193b46cd01821a169">&#9670;&nbsp;</a></span>sufficient_decrease_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cannon::ml::sufficient_decrease_condition </td>
          <td>(</td>
          <td class="paramtype">RealFunc&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiFunc&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether the input step along the input direction satisfies the Armijo sufficient decrease condition with respect to the function under consideration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function being optimized </td></tr>
    <tr><td class="paramname">f_grad</td><td>Gradient of the function being optimized </td></tr>
    <tr><td class="paramname">x</td><td>Current state from which to compute sufficient decrease </td></tr>
    <tr><td class="paramname">step</td><td>Step along direction from x </td></tr>
    <tr><td class="paramname">direction</td><td>Optimization direction </td></tr>
    <tr><td class="paramname">c_1</td><td>Sufficient decrease parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the sufficient decrease condition is satisfied. </dd></dl>

</div>
</div>
<a id="ade9547572106b1cc75347e60783441cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9547572106b1cc75347e60783441cb">&#9670;&nbsp;</a></span>wolfe_condition_line_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cannon::ml::wolfe_condition_line_search </td>
          <td>(</td>
          <td class="paramtype">RealFunc&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiFunc&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step_1</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_1</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_2</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the optimal line search step along the input direction, moving as far as possible while satisfying the Wolfe conditions. Note that this is the minimizing step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be minimized. </td></tr>
    <tr><td class="paramname">f_grad</td><td>Gradient function for the function to be minimized. </td></tr>
    <tr><td class="paramname">x</td><td>State to conduct line search from </td></tr>
    <tr><td class="paramname">direction</td><td>Direction for line search </td></tr>
    <tr><td class="paramname">step_1</td><td>Initial step to consider </td></tr>
    <tr><td class="paramname">c_1</td><td>Sufficient decrease parameter </td></tr>
    <tr><td class="paramname">c_2</td><td>Curvature parameter </td></tr>
    <tr><td class="paramname">iterations</td><td>Maximum number of iterations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66585f51a99a678498d34bbea0d7cf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66585f51a99a678498d34bbea0d7cf47">&#9670;&nbsp;</a></span>wolfe_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cannon::ml::wolfe_conditions </td>
          <td>(</td>
          <td class="paramtype">RealFunc&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiFunc&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether both Wolfe conditions are satisfied by the input step along the input direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function being optimized </td></tr>
    <tr><td class="paramname">f_grad</td><td>Gradient of the function being optimized </td></tr>
    <tr><td class="paramname">x</td><td>Current state from which to compute sufficient decrease </td></tr>
    <tr><td class="paramname">step</td><td>Step along direction from x </td></tr>
    <tr><td class="paramname">direction</td><td>Optimization direction </td></tr>
    <tr><td class="paramname">c_1</td><td>Sufficient decrease parameter </td></tr>
    <tr><td class="paramname">c_2</td><td>Curvature parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cannon</b></li><li class="navelem"><a class="el" href="namespacecannon_1_1ml.html">ml</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
