#include <glad/glad.h>
#include <thread>

#include <imgui.h>
#include <imgui_stdlib.h>

#include <cannon/graphics/viewer_3d.hpp>
#include <cannon/graphics/framebuffer.hpp>
#include <cannon/log/registry.hpp>

using namespace cannon::graphics;
using namespace cannon::log;

void test() {
  std::vector<std::string> faces;
  faces.push_back("assets/skybox/right.jpg");
  faces.push_back("assets/skybox/left.jpg");
  faces.push_back("assets/skybox/top.jpg");
  faces.push_back("assets/skybox/bottom.jpg");
  faces.push_back("assets/skybox/front.jpg");
  faces.push_back("assets/skybox/back.jpg");

  Viewer3D viewer;
  viewer.set_skybox(faces);

  auto gbuf_program = std::make_shared<ShaderProgram>("gbuffer_shader");
  gbuf_program->attach_vertex_shader("shaders/mvp_normals_tex.vert");
  gbuf_program->attach_fragment_shader("shaders/gbuffer.frag");
  gbuf_program->link();

  std::vector<std::shared_ptr<Texture>> attachments;
  attachments.push_back(std::make_shared<Texture>(viewer.w.width,
        viewer.w.height, GL_RGBA16F, GL_FLOAT));
  attachments.push_back(std::make_shared<Texture>(viewer.w.width,
        viewer.w.height, GL_RGBA16F, GL_FLOAT));
  attachments.push_back(std::make_shared<Texture>(viewer.w.width,
        viewer.w.height, GL_RGBA, GL_UNSIGNED_BYTE));

  viewer.w.set_clear_color({0.0, 0.0, 0.0, 1.0});

  auto fb = std::make_shared<Framebuffer>(attachments, viewer.w.width,
      viewer.w.height, "gbuffer framebuffer");
  auto rp = std::make_shared<RenderPass>("gbuffer pass", fb, gbuf_program, [&](){
            viewer.disable_skybox();
            Vector3f c_pos = viewer.c.get_pos();
            Vector4f tmp_pos;
            tmp_pos << c_pos[0],
                       c_pos[1],
                       c_pos[2],
                       1.0;
            gbuf_program->set_uniform("viewPos", tmp_pos);
            viewer.apply_light_collection(gbuf_program);
            
            fb->color_attachments[0]->unbind();
            viewer.draw_scene_geom(gbuf_program);
            viewer.enable_skybox();
      });

  auto lighting_program = std::make_shared<ShaderProgram>("lighting_shader");
  lighting_program->attach_vertex_shader("shaders/pass_pos_tex.vert");
  lighting_program->attach_fragment_shader("shaders/deferred_lighting.frag");
  lighting_program->link();

  auto fb2 = std::make_shared<Framebuffer>(viewer.w.width, viewer.w.height, "lighting framebuffer");
  auto rp2 = std::make_shared<RenderPass>("lighting pass", fb2, lighting_program, [&](){
        Vector3f c_pos = viewer.c.get_pos();
        Vector4f tmp_pos;
        tmp_pos << c_pos[0],
                   c_pos[1],
                   c_pos[2],
                   1.0;
        lighting_program->set_uniform("viewPos", tmp_pos);
        lighting_program->set_uniform("shininess", (float)32.0);
        viewer.apply_light_collection(lighting_program);

        fb2->quad->draw(lighting_program, attachments);
      });

  viewer.add_render_pass(rp);
  viewer.add_render_pass(rp2);

  viewer.spawn_cube();
  viewer.render_loop_multipass([&] {});

  log_info("Render loop finished");
}

int main() {

  std::thread render_thread(test);

  // There appears to be a driver bug that causes a segfault on thread destruction
  render_thread.join();
}
