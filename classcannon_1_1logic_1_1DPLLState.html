<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cannon: cannon::logic::DPLLState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cannon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcannon_1_1logic_1_1DPLLState.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcannon_1_1logic_1_1DPLLState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cannon::logic::DPLLState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing the state of the DPLL/CDCL algorithm. Manages a frontier of formula states in order to perform search for satisfying assignments.  
 <a href="classcannon_1_1logic_1_1DPLLState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dpll_8hpp_source.html">dpll.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for cannon::logic::DPLLState:</div>
<div class="dyncontent">
<div class="center"><img src="classcannon_1_1logic_1_1DPLLState__coll__graph.png" border="0" usemap="#cannon_1_1logic_1_1DPLLState_coll__map" alt="Collaboration graph"/></div>
<map name="cannon_1_1logic_1_1DPLLState_coll__map" id="cannon_1_1logic_1_1DPLLState_coll__map">
<area shape="rect" title="Class representing the state of the DPLL/CDCL algorithm. Manages a frontier of formula states in orde..." alt="" coords="312,64,495,91"/>
<area shape="rect" href="classcannon_1_1logic_1_1CNFFormula.html" title="Class representing a Conjunctive Normal Form formula, which is a conjunction of Clauses." alt="" coords="5,5,201,32"/>
<area shape="rect" href="classcannon_1_1logic_1_1AssignmentHeuristic.html" title="Functor representing an assignment choice heuristic." alt="" coords="7,57,200,98"/>
<area shape="rect" href="classcannon_1_1logic_1_1PropositionHeuristic.html" title="Functor representing a proposition choice heuristic." alt="" coords="9,122,198,163"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b4c8de64557085ca04c1ad015a38c74"><td class="memItemLeft" align="right" valign="top"><a id="a4b4c8de64557085ca04c1ad015a38c74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a4b4c8de64557085ca04c1ad015a38c74">DPLLState</a> (<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> f, <a class="el" href="classcannon_1_1logic_1_1PropositionHeuristic.html">PropositionHeuristic</a> ph, <a class="el" href="classcannon_1_1logic_1_1AssignmentHeuristic.html">AssignmentHeuristic</a> ah)</td></tr>
<tr class="memdesc:a4b4c8de64557085ca04c1ad015a38c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor taking a formula to check for satisfiability, proposition heuristic, and assignment heuristic. <br /></td></tr>
<tr class="separator:a4b4c8de64557085ca04c1ad015a38c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b568c12a8941de71663b2c7ff83a75c"><td class="memItemLeft" align="right" valign="top">Simplification&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a1b568c12a8941de71663b2c7ff83a75c">check_simplification_size</a> (const Simplification &amp;s)</td></tr>
<tr class="memdesc:a1b568c12a8941de71663b2c7ff83a75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check simplification size and, if the simplification is too short, extend it. This behavior is necessary because the formula may grow as we do clause learning.  <a href="classcannon_1_1logic_1_1DPLLState.html#a1b568c12a8941de71663b2c7ff83a75c">More...</a><br /></td></tr>
<tr class="separator:a1b568c12a8941de71663b2c7ff83a75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88455537b31e85b1609c698dd337dbb2"><td class="memItemLeft" align="right" valign="top">Assignment&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a88455537b31e85b1609c698dd337dbb2">do_pure_literal_deletion</a> (const Assignment &amp;a_0, const Simplification &amp;s_0)</td></tr>
<tr class="memdesc:a88455537b31e85b1609c698dd337dbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pure literals in the current formula and "delete" them by assigning them satisfying values.  <a href="classcannon_1_1logic_1_1DPLLState.html#a88455537b31e85b1609c698dd337dbb2">More...</a><br /></td></tr>
<tr class="separator:a88455537b31e85b1609c698dd337dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2837adca70a6063d82b86f2b2cf38b89"><td class="memItemLeft" align="right" valign="top"><a id="a2837adca70a6063d82b86f2b2cf38b89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a2837adca70a6063d82b86f2b2cf38b89">restart</a> ()</td></tr>
<tr class="memdesc:a2837adca70a6063d82b86f2b2cf38b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart DPLL search. Primarily called when a unit clause is learned, as this can dramatically affect the search. <br /></td></tr>
<tr class="separator:a2837adca70a6063d82b86f2b2cf38b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22950628e110f5fa3530ef5c8d03cce"><td class="memItemLeft" align="right" valign="top"><a id="ab22950628e110f5fa3530ef5c8d03cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ab22950628e110f5fa3530ef5c8d03cce">do_preprocessing</a> ()</td></tr>
<tr class="memdesc:ab22950628e110f5fa3530ef5c8d03cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocess formula by deleting pure literals, simplifying as much as possible, and resolving unit clauses. <br /></td></tr>
<tr class="separator:ab22950628e110f5fa3530ef5c8d03cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e23aaa6320d8925f0bef266c3ed391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#aa0e23aaa6320d8925f0bef266c3ed391">do_all_resolutions</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;c)</td></tr>
<tr class="memdesc:aa0e23aaa6320d8925f0bef266c3ed391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do all possible resolutions for the input clause and input formula state.  <a href="classcannon_1_1logic_1_1DPLLState.html#aa0e23aaa6320d8925f0bef266c3ed391">More...</a><br /></td></tr>
<tr class="separator:aa0e23aaa6320d8925f0bef266c3ed391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcfad15194b634484526d39acba2eb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a5dcfad15194b634484526d39acba2eb9">compute_lbd</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, const <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;c)</td></tr>
<tr class="memdesc:a5dcfad15194b634484526d39acba2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <a class="el" href="classcannon_1_1logic_1_1Literal.html" title="Class representing a single literal in a CNF formula.">Literal</a> Block Distance (number of distinct decision levels) of the input clause.  <a href="classcannon_1_1logic_1_1DPLLState.html#a5dcfad15194b634484526d39acba2eb9">More...</a><br /></td></tr>
<tr class="separator:a5dcfad15194b634484526d39acba2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed08b9fad3a61250bfd24c1bdca39c26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#aed08b9fad3a61250bfd24c1bdca39c26">learn_clause</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, unsigned int c, unsigned int prop)</td></tr>
<tr class="memdesc:aed08b9fad3a61250bfd24c1bdca39c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn a new clause for the formula being searched over by performing all possible resolutions, then add it to the formula.  <a href="classcannon_1_1logic_1_1DPLLState.html#aed08b9fad3a61250bfd24c1bdca39c26">More...</a><br /></td></tr>
<tr class="separator:aed08b9fad3a61250bfd24c1bdca39c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9627e9e55413fc1ecd521da293717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a0ee9627e9e55413fc1ecd521da293717">update_watch_and_propagate</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, std::set&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt; unit_clauses)</td></tr>
<tr class="memdesc:a0ee9627e9e55413fc1ecd521da293717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate assignments implied by the input unit clauses, then update the watched list and handle any new conflicts or unit clauses. The cascade of changes to the formula done by this method can save a lot of unnecessary recursion.  <a href="classcannon_1_1logic_1_1DPLLState.html#a0ee9627e9e55413fc1ecd521da293717">More...</a><br /></td></tr>
<tr class="separator:a0ee9627e9e55413fc1ecd521da293717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eebd83075011707ff9979f39d3ebd4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a26eebd83075011707ff9979f39d3ebd4">update_watched</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, unsigned int prop)</td></tr>
<tr class="memdesc:a26eebd83075011707ff9979f39d3ebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update watched list, given that the input proposition has been assigned. The assignment of a previously unassigned proposition watched for a particular clause triggers watching of a new proposition in that clause. Updating the watched list also lets us identify unit clauses and conflicts.  <a href="classcannon_1_1logic_1_1DPLLState.html#a26eebd83075011707ff9979f39d3ebd4">More...</a><br /></td></tr>
<tr class="separator:a26eebd83075011707ff9979f39d3ebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21def9186e2d16e2b4771873a0232500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a21def9186e2d16e2b4771873a0232500">do_unit_preference</a> (std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs, unsigned int unit_clause)</td></tr>
<tr class="memdesc:a21def9186e2d16e2b4771873a0232500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the input formula state by performing the "unit
preference" rule of DPLL, i.e., setting the proposition in the input unit clause to the satisfying value implied by the unit clause.  <a href="classcannon_1_1logic_1_1DPLLState.html#a21def9186e2d16e2b4771873a0232500">More...</a><br /></td></tr>
<tr class="separator:a21def9186e2d16e2b4771873a0232500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce6f148e2274aaa90563fa38a67f6c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a9ce6f148e2274aaa90563fa38a67f6c8">do_splitting_rule</a> (const std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; fs)</td></tr>
<tr class="memdesc:a9ce6f148e2274aaa90563fa38a67f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the "splitting rule" part of DPLL, i.e., choose a proposition heuristically and formula states with both possible assignments to the DPLL frontier.  <a href="classcannon_1_1logic_1_1DPLLState.html#a9ce6f148e2274aaa90563fa38a67f6c8">More...</a><br /></td></tr>
<tr class="separator:a9ce6f148e2274aaa90563fa38a67f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799fbce0aadb79f27a9e392eb86ba71b"><td class="memItemLeft" align="right" valign="top"><a id="a799fbce0aadb79f27a9e392eb86ba71b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a799fbce0aadb79f27a9e392eb86ba71b">do_backjump</a> ()</td></tr>
<tr class="memdesc:a799fbce0aadb79f27a9e392eb86ba71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the state of DPLL search to the last open decision level. <br /></td></tr>
<tr class="separator:a799fbce0aadb79f27a9e392eb86ba71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1abb90e081163d5e47e58a9ac2cfe13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ad1abb90e081163d5e47e58a9ac2cfe13">iterate</a> ()</td></tr>
<tr class="memdesc:ad1abb90e081163d5e47e58a9ac2cfe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an iteration of the DPLL algorithm by popping a formula state from the frontier and processing it.  <a href="classcannon_1_1logic_1_1DPLLState.html#ad1abb90e081163d5e47e58a9ac2cfe13">More...</a><br /></td></tr>
<tr class="separator:ad1abb90e081163d5e47e58a9ac2cfe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae627bb92d08389b785e3089cfc1f7393"><td class="memItemLeft" align="right" valign="top"><a id="ae627bb92d08389b785e3089cfc1f7393"></a>
<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ae627bb92d08389b785e3089cfc1f7393">formula_</a></td></tr>
<tr class="memdesc:ae627bb92d08389b785e3089cfc1f7393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base formula whose satisfiability is to be evaluated. <br /></td></tr>
<tr class="separator:ae627bb92d08389b785e3089cfc1f7393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc085017d2717c71144615d59c26f1"><td class="memItemLeft" align="right" valign="top"><a id="aebcc085017d2717c71144615d59c26f1"></a>
std::stack&lt; std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#aebcc085017d2717c71144615d59c26f1">frontier_</a></td></tr>
<tr class="memdesc:aebcc085017d2717c71144615d59c26f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DPLL search frontier. <br /></td></tr>
<tr class="separator:aebcc085017d2717c71144615d59c26f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ea9ea501cd044016bcb0500e4a56a9"><td class="memItemLeft" align="right" valign="top"><a id="a69ea9ea501cd044016bcb0500e4a56a9"></a>
<a class="el" href="classcannon_1_1logic_1_1PropositionHeuristic.html">PropositionHeuristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a69ea9ea501cd044016bcb0500e4a56a9">ph_</a></td></tr>
<tr class="memdesc:a69ea9ea501cd044016bcb0500e4a56a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proposition choice heuristic. <br /></td></tr>
<tr class="separator:a69ea9ea501cd044016bcb0500e4a56a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c681be9b62669904954fcf2d20e4cd"><td class="memItemLeft" align="right" valign="top"><a id="af9c681be9b62669904954fcf2d20e4cd"></a>
<a class="el" href="classcannon_1_1logic_1_1AssignmentHeuristic.html">AssignmentHeuristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#af9c681be9b62669904954fcf2d20e4cd">ah_</a></td></tr>
<tr class="memdesc:af9c681be9b62669904954fcf2d20e4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment choice heuristic. <br /></td></tr>
<tr class="separator:af9c681be9b62669904954fcf2d20e4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b72af38589655d9d3d92ef608ebb5"><td class="memItemLeft" align="right" valign="top"><a id="a923b72af38589655d9d3d92ef608ebb5"></a>
std::vector&lt; std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a923b72af38589655d9d3d92ef608ebb5">watched</a></td></tr>
<tr class="memdesc:a923b72af38589655d9d3d92ef608ebb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watched list. <br /></td></tr>
<tr class="separator:a923b72af38589655d9d3d92ef608ebb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ab07f363722e43edbce81ce041e1b1"><td class="memItemLeft" align="right" valign="top"><a id="a26ab07f363722e43edbce81ce041e1b1"></a>
std::vector&lt; std::map&lt; unsigned int, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a26ab07f363722e43edbce81ce041e1b1">clause_watched</a></td></tr>
<tr class="memdesc:a26ab07f363722e43edbce81ce041e1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse watched list. <br /></td></tr>
<tr class="separator:a26ab07f363722e43edbce81ce041e1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbb11a914a82679aedbc6bca2bc0376"><td class="memItemLeft" align="right" valign="top"><a id="acfbb11a914a82679aedbc6bca2bc0376"></a>
VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#acfbb11a914a82679aedbc6bca2bc0376">vsids_</a></td></tr>
<tr class="memdesc:acfbb11a914a82679aedbc6bca2bc0376"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIDS weights for proposition choice heuristic. <br /></td></tr>
<tr class="separator:acfbb11a914a82679aedbc6bca2bc0376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ff0b073a27fb5b9f564c42e68469de"><td class="memItemLeft" align="right" valign="top"><a id="a24ff0b073a27fb5b9f564c42e68469de"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a24ff0b073a27fb5b9f564c42e68469de">vsids_decay_</a> = 0.99</td></tr>
<tr class="memdesc:a24ff0b073a27fb5b9f564c42e68469de"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIDS decay parameter. <br /></td></tr>
<tr class="separator:a24ff0b073a27fb5b9f564c42e68469de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb597fc79e57141222d4203e54c3f41"><td class="memItemLeft" align="right" valign="top"><a id="abcb597fc79e57141222d4203e54c3f41"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#abcb597fc79e57141222d4203e54c3f41">lbd_ema_</a> = 1.0</td></tr>
<tr class="memdesc:abcb597fc79e57141222d4203e54c3f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">LBD threshold. <br /></td></tr>
<tr class="separator:abcb597fc79e57141222d4203e54c3f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b0a16ac5b3e0dae2c46d4ed4177320"><td class="memItemLeft" align="right" valign="top"><a id="ad4b0a16ac5b3e0dae2c46d4ed4177320"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ad4b0a16ac5b3e0dae2c46d4ed4177320">lbd_ema_decay_</a> = 0.95</td></tr>
<tr class="memdesc:ad4b0a16ac5b3e0dae2c46d4ed4177320"><td class="mdescLeft">&#160;</td><td class="mdescRight">LBD threshold decay parameter. <br /></td></tr>
<tr class="separator:ad4b0a16ac5b3e0dae2c46d4ed4177320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f12647455f53a954aea9c00ff97ea9"><td class="memItemLeft" align="right" valign="top"><a id="ad0f12647455f53a954aea9c00ff97ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ad0f12647455f53a954aea9c00ff97ea9">iterations_</a> = 0</td></tr>
<tr class="memdesc:ad0f12647455f53a954aea9c00ff97ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations done since last restart. <br /></td></tr>
<tr class="separator:ad0f12647455f53a954aea9c00ff97ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201fbbdd8223c022837f2195ff0f5668"><td class="memItemLeft" align="right" valign="top"><a id="a201fbbdd8223c022837f2195ff0f5668"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a201fbbdd8223c022837f2195ff0f5668">restart_iterations_</a> = 1000</td></tr>
<tr class="memdesc:a201fbbdd8223c022837f2195ff0f5668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration restart threshold (can speed up solution) <br /></td></tr>
<tr class="separator:a201fbbdd8223c022837f2195ff0f5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3fc367b3c665d4d1251f96fa2d3aa0"><td class="memItemLeft" align="right" valign="top"><a id="a4a3fc367b3c665d4d1251f96fa2d3aa0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a4a3fc367b3c665d4d1251f96fa2d3aa0">total_iterations</a> = 0</td></tr>
<tr class="memdesc:a4a3fc367b3c665d4d1251f96fa2d3aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of iterations. <br /></td></tr>
<tr class="separator:a4a3fc367b3c665d4d1251f96fa2d3aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86846f61faff75b4b50c1a48e33b26a9"><td class="memItemLeft" align="right" valign="top"><a id="a86846f61faff75b4b50c1a48e33b26a9"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a86846f61faff75b4b50c1a48e33b26a9">learned_usage</a></td></tr>
<tr class="memdesc:a86846f61faff75b4b50c1a48e33b26a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage of each proposition in learned clauses (for heuristics) <br /></td></tr>
<tr class="separator:a86846f61faff75b4b50c1a48e33b26a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad217801153ca3a938068f5dd31be167"><td class="memItemLeft" align="right" valign="top"><a id="aad217801153ca3a938068f5dd31be167"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#aad217801153ca3a938068f5dd31be167">max_original_clause_size_</a></td></tr>
<tr class="memdesc:aad217801153ca3a938068f5dd31be167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum clause size in original formula. <br /></td></tr>
<tr class="separator:aad217801153ca3a938068f5dd31be167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad737b12b99460f05970df3bf4b7b6ab7"><td class="memItemLeft" align="right" valign="top"><a id="ad737b12b99460f05970df3bf4b7b6ab7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ad737b12b99460f05970df3bf4b7b6ab7">num_original_clauses_</a></td></tr>
<tr class="memdesc:ad737b12b99460f05970df3bf4b7b6ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of clauses in original formula. <br /></td></tr>
<tr class="separator:ad737b12b99460f05970df3bf4b7b6ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f29487d8a6c0fb64db78cd32fcef4fc"><td class="memItemLeft" align="right" valign="top"><a id="a3f29487d8a6c0fb64db78cd32fcef4fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a3f29487d8a6c0fb64db78cd32fcef4fc">found_unsat_</a> = false</td></tr>
<tr class="memdesc:a3f29487d8a6c0fb64db78cd32fcef4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the formula has been found to be unsatisfiable. <br /></td></tr>
<tr class="separator:a3f29487d8a6c0fb64db78cd32fcef4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a217526ebcb65649839f8875ad35931"><td class="memItemLeft" align="right" valign="top"><a id="a8a217526ebcb65649839f8875ad35931"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a8a217526ebcb65649839f8875ad35931">should_restart_</a> = false</td></tr>
<tr class="memdesc:a8a217526ebcb65649839f8875ad35931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the DPLL algorithm should restart. <br /></td></tr>
<tr class="separator:a8a217526ebcb65649839f8875ad35931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2604d6874786849ede21ef25e6b9bfc0"><td class="memItemLeft" align="right" valign="top"><a id="a2604d6874786849ede21ef25e6b9bfc0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a2604d6874786849ede21ef25e6b9bfc0">backjump_</a> = -1</td></tr>
<tr class="memdesc:a2604d6874786849ede21ef25e6b9bfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backjump level, i.e., last open decision level. <br /></td></tr>
<tr class="separator:a2604d6874786849ede21ef25e6b9bfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989f843e06f2c3fc659fbc5b98f64d59"><td class="memItemLeft" align="right" valign="top"><a id="a989f843e06f2c3fc659fbc5b98f64d59"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#a989f843e06f2c3fc659fbc5b98f64d59">should_backjump_</a> = false</td></tr>
<tr class="memdesc:a989f843e06f2c3fc659fbc5b98f64d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the DPLL algorithm should backjump. <br /></td></tr>
<tr class="separator:a989f843e06f2c3fc659fbc5b98f64d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57748b8a586405ec01ff7739303b927"><td class="memItemLeft" align="right" valign="top"><a id="ab57748b8a586405ec01ff7739303b927"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#ab57748b8a586405ec01ff7739303b927">learned_clause_</a> = false</td></tr>
<tr class="memdesc:ab57748b8a586405ec01ff7739303b927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a clause has been learned. <br /></td></tr>
<tr class="separator:ab57748b8a586405ec01ff7739303b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adff1d2f1e0fc5e660a01e1b6fb96bc11"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html#adff1d2f1e0fc5e660a01e1b6fb96bc11">dpll</a> (<a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a> f, PropFunc ph_func, AssignFunc ah_func, const std::chrono::seconds cutoff)</td></tr>
<tr class="memdesc:adff1d2f1e0fc5e660a01e1b6fb96bc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached.  <a href="classcannon_1_1logic_1_1DPLLState.html#adff1d2f1e0fc5e660a01e1b6fb96bc11">More...</a><br /></td></tr>
<tr class="separator:adff1d2f1e0fc5e660a01e1b6fb96bc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing the state of the DPLL/CDCL algorithm. Manages a frontier of formula states in order to perform search for satisfying assignments. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b568c12a8941de71663b2c7ff83a75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b568c12a8941de71663b2c7ff83a75c">&#9670;&nbsp;</a></span>check_simplification_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Simplification DPLLState::check_simplification_size </td>
          <td>(</td>
          <td class="paramtype">const Simplification &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check simplification size and, if the simplification is too short, extend it. This behavior is necessary because the formula may grow as we do clause learning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Simplification to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new simplification whose size is correct. </dd></dl>

</div>
</div>
<a id="a5dcfad15194b634484526d39acba2eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcfad15194b634484526d39acba2eb9">&#9670;&nbsp;</a></span>compute_lbd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DPLLState::compute_lbd </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the <a class="el" href="classcannon_1_1logic_1_1Literal.html" title="Class representing a single literal in a CNF formula.">Literal</a> Block Distance (number of distinct decision levels) of the input clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The current formula state. </td></tr>
    <tr><td class="paramname">c</td><td>The clause to compute LBD for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LBD for the input clause. </dd></dl>

</div>
</div>
<a id="aa0e23aaa6320d8925f0bef266c3ed391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e23aaa6320d8925f0bef266c3ed391">&#9670;&nbsp;</a></span>do_all_resolutions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DPLLState::do_all_resolutions </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcannon_1_1logic_1_1Clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do all possible resolutions for the input clause and input formula state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The state of the formula to do resolutions on. </td></tr>
    <tr><td class="paramname">c</td><td>The clause to resolve with every other. Will be modified as resolutions occur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88455537b31e85b1609c698dd337dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88455537b31e85b1609c698dd337dbb2">&#9670;&nbsp;</a></span>do_pure_literal_deletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment DPLLState::do_pure_literal_deletion </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>a_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Simplification &amp;&#160;</td>
          <td class="paramname"><em>s_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find pure literals in the current formula and "delete" them by assigning them satisfying values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_0</td><td>Current assignment </td></tr>
    <tr><td class="paramname">s_0</td><td>Current simplification</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new assignment which deals with pure literals. </dd></dl>

</div>
</div>
<a id="a9ce6f148e2274aaa90563fa38a67f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce6f148e2274aaa90563fa38a67f6c8">&#9670;&nbsp;</a></span>do_splitting_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DPLLState::do_splitting_rule </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the "splitting rule" part of DPLL, i.e., choose a proposition heuristically and formula states with both possible assignments to the DPLL frontier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The formula state to split from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether splitting was possible. </dd></dl>

</div>
</div>
<a id="a21def9186e2d16e2b4771873a0232500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21def9186e2d16e2b4771873a0232500">&#9670;&nbsp;</a></span>do_unit_preference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DPLLState::do_unit_preference </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>unit_clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the input formula state by performing the "unit
preference" rule of DPLL, i.e., setting the proposition in the input unit clause to the satisfying value implied by the unit clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The formula state to apply unit preference on. </td></tr>
    <tr><td class="paramname">unit_clause</td><td>Index of unit clause. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1abb90e081163d5e47e58a9ac2cfe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1abb90e081163d5e47e58a9ac2cfe13">&#9670;&nbsp;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment &gt; DPLLState::iterate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an iteration of the DPLL algorithm by popping a formula state from the frontier and processing it. </p>
<p>The Assignment portion of the return value will be empty unless the DPLLResult part is "Satisfiable"</p>
<dl class="section return"><dt>Returns</dt><dd>Unsatisfiable if the input formula was provably unsatisfiable, Satisfiable if a satisfying assignment was found, and Unknown if more iterations are needed. </dd></dl>

</div>
</div>
<a id="aed08b9fad3a61250bfd24c1bdca39c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed08b9fad3a61250bfd24c1bdca39c26">&#9670;&nbsp;</a></span>learn_clause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DPLLState::learn_clause </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn a new clause for the formula being searched over by performing all possible resolutions, then add it to the formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The current formula state. </td></tr>
    <tr><td class="paramname">c</td><td>Index of the existing clause to use for learning. </td></tr>
    <tr><td class="paramname">prop</td><td>Proposition that led to conflict triggering learning.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Level of decision tree to backjump to, or -1 if something went wrong. </dd></dl>

</div>
</div>
<a id="a0ee9627e9e55413fc1ecd521da293717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee9627e9e55413fc1ecd521da293717">&#9670;&nbsp;</a></span>update_watch_and_propagate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DPLLState::update_watch_and_propagate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt;&#160;</td>
          <td class="paramname"><em>unit_clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate assignments implied by the input unit clauses, then update the watched list and handle any new conflicts or unit clauses. The cascade of changes to the formula done by this method can save a lot of unnecessary recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The current formula state. </td></tr>
    <tr><td class="paramname">unit_clauses</td><td>Unit clauses to use for initial propagation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a conflict was found during propagation. </dd></dl>

</div>
</div>
<a id="a26eebd83075011707ff9979f39d3ebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eebd83075011707ff9979f39d3ebd4">&#9670;&nbsp;</a></span>update_watched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, std::pair&lt; int, int &gt; &gt; DPLLState::update_watched </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcannon_1_1logic_1_1FormulaState.html">FormulaState</a> &gt;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update watched list, given that the input proposition has been assigned. The assignment of a previously unassigned proposition watched for a particular clause triggers watching of a new proposition in that clause. Updating the watched list also lets us identify unit clauses and conflicts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The current formula state </td></tr>
    <tr><td class="paramname">prop</td><td>The proposition which was recently assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of sets of indices. The first set is the discovered unit clauses, and the second set is the discovered conflicts. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adff1d2f1e0fc5e660a01e1b6fb96bc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff1d2f1e0fc5e660a01e1b6fb96bc11">&#9670;&nbsp;</a></span>dpll</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacecannon_1_1logic.html#a0bbb8122b6d16c0fcda35461be74b9ca">DPLLResult</a>, Assignment, int&gt; dpll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcannon_1_1logic_1_1CNFFormula.html">CNFFormula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropFunc&#160;</td>
          <td class="paramname"><em>ph_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignFunc&#160;</td>
          <td class="paramname"><em>ah_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds&#160;</td>
          <td class="paramname"><em>cutoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to run the entire DPLL/CDCL algorithm, iterating until a non-Unknown result is returned or a cutoff execution time is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The formula to check for satisfiability </td></tr>
    <tr><td class="paramname">ph_func</td><td>Proposition choice heuristic </td></tr>
    <tr><td class="paramname">ah_func</td><td>Assignment choice heuristic </td></tr>
    <tr><td class="paramname">cutoff</td><td>Maximum amount of time that the algorithm should run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the DPLL algorithm. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/cannon/cannon/cannon/logic/<a class="el" href="dpll_8hpp_source.html">dpll.hpp</a></li>
<li>/home/runner/work/cannon/cannon/cannon/logic/dpll.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cannon</b></li><li class="navelem"><a class="el" href="namespacecannon_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="classcannon_1_1logic_1_1DPLLState.html">DPLLState</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
